{
	"meta": {
		"generatedAt": "2025-09-18T03:43:16.743Z",
		"tasksAnalyzed": 12,
		"totalTasks": 22,
		"analysisCount": 12,
		"thresholdScore": 5,
		"projectName": "Taskmaster",
		"usedResearch": true
	},
	"complexityAnalysis": [
		{
			"taskId": 8,
			"taskTitle": "Firmware: Implement Scheduling Engine",
			"complexityScore": 7,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Based on the analysis of `firmware/src/main.cpp`, the task is to implement a new scheduling engine. You will need to add NTP client logic to `setup()` after WiFi connects, define a `Schedule` struct, and create a new `scheduler.cpp`/`.h` module. This module should contain a `checkSchedules()` function that is called from the main `loop()`. This function will iterate through a global vector of schedules, compare against the current time (fetched via a non-blocking mechanism in the loop), and call the existing `setPumpState()` function when a state change is required. Ensure you add `SCHEDULE` to the `StateChangeOrigin` enum.",
			"reasoning": "The codebase has no existing time synchronization (NTP) or scheduling logic. This feature must be built from scratch. It involves adding new libraries, defining data structures for schedules, managing time in the main loop, and creating a new evaluation function. The complexity is moderated by the existence of a clean `setPumpState` function, which can be called directly by the new scheduler, simplifying the final integration step."
		},
		{
			"taskId": 9,
			"taskTitle": "Frontend: Create Schedule Management UI",
			"complexityScore": 7,
			"recommendedSubtasks": 5,
			"expansionPrompt": "You need to build a new schedule management feature in the Next.js frontend. Start by creating a `ScheduleDialog` component in `frontend/src/components/schedules/`. Use Shadcn's `<Dialog>` and add a trigger button to `page.tsx`. Inside the dialog, use `useEffect` to fetch data from the `/api/schedules` endpoint and display it in a Shadcn `<Table>`. Add a form using `react-hook-form` and `zod` for creating new schedules (POST) and include a delete button in each table row to handle deletion (DELETE). Ensure the table refreshes automatically after creation or deletion.",
			"reasoning": "The frontend codebase in `frontend/src/app/page.tsx` is basic and contains no components or logic for schedule management. This task requires building a complete CRUD interface from scratch using Shadcn/UI components like Dialog, Table, and Form. It involves creating new components, managing local state, and implementing multiple API client functions for fetching, creating, and deleting schedules."
		},
		{
			"taskId": 10,
			"taskTitle": "Firmware: Implement RGB LED PWM Control",
			"complexityScore": 4,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Based on `firmware/src/main.cpp`, implement RGB LED control. First, define GPIO pins and LEDC channel constants at the top of the file. In `setup()`, use `ledcSetup()` and `ledcAttachPin()` to configure the three PWM channels. Create a `setRgbColor(r, g, b)` function that calls `ledcWrite()` and stores the state in global variables. Extend the `handleWebSocketMessage` function with a new `else if` block to parse a `set_rgb` command and call your new function. Finally, modify `broadcastState()` to include the current RGB values in the JSON payload.",
			"reasoning": "The project does not currently use the ESP32's LEDC (PWM) peripheral. This task requires adding new hardware initialization code in `setup()` for the three RGB channels. However, the pattern for adding new functionality is clear. The `handleWebSocketMessage` function in `src/main.cpp` can be easily extended with an `else if` block for a `set_rgb` action. Similarly, the new RGB state can be added to the JSON object in the existing `broadcastState` function."
		},
		{
			"taskId": 12,
			"taskTitle": "Firmware: Integrate Tuya IoT SDK for Cloud Connectivity",
			"complexityScore": 9,
			"recommendedSubtasks": 5,
			"expansionPrompt": "This is a major integration. Start by adding the `tuya/tuya-iot-sdk-for-embeded-cpp` library to `lib_deps` in `firmware/platformio.ini`. In `src/main.cpp`, you will need to include the Tuya headers and initialize the SDK in `setup()` using your Product ID. Implement the required callback functions for status changes (`on_tuya_status_changed`) and incoming commands (`dp_process`). Modify the WiFi connection logic to trigger Tuya's provisioning mode (`tuya_iot_wf_gw_unactive`) on failure. Finally, ensure the `tuya_iot_sdk_loop()` function is called within the main `loop()`.",
			"reasoning": "The codebase has zero existing integration with the Tuya ecosystem. This task requires adding the Tuya IoT SDK as a new dependency in `platformio.ini` and writing a significant amount of boilerplate code in `src/main.cpp`. This includes initializing the SDK, implementing a new event-driven callback system for Tuya events (like provisioning and cloud connection), and integrating Tuya's own loop/handler function into the main `loop()`. This is a complex, high-risk integration that fundamentally adds a new layer to the firmware's architecture."
		},
		{
			"taskId": 13,
			"taskTitle": "Tuya Platform: Define Device and Data Points (DPs)",
			"complexityScore": 1,
			"recommendedSubtasks": 5,
			"expansionPrompt": "This is a configuration task on the Tuya IoT Platform. Log in and create a new product. In the 'Function Definition' section, create custom data points (DPs). You will need to add four 'Boolean' DPs for the pumps (e.g., DPID 101-104), two 'Value' DPs for temperature and luminosity, and one 'Colour' or 'String' DP for the RGB light. Document these DP IDs in the project's README or a new config header for use in Task 14.",
			"reasoning": "This task involves no code changes within the project repository. It is a purely administrative and configuration task performed on the external Tuya IoT Developer Platform website. The complexity is minimal from a development standpoint, as it only requires navigating a web UI and defining product features according to the project's requirements."
		},
		{
			"taskId": 14,
			"taskTitle": "Firmware: Map Device State to Tuya Data Points (DPs)",
			"complexityScore": 6,
			"recommendedSubtasks": 5,
			"expansionPrompt": "To implement two-way Tuya sync, first define all your Tuya DPIDs as constants in a config file. Create helper functions like `report_dp_bool(dpid, value)` that wrap the Tuya SDK's update call. Modify `setPumpState` in `src/main.cpp` to call this helper after a state change. In the main `loop`, after reading sensor values, call the reporting helpers for temperature and luminosity. Finally, in the `dp_process` callback (from Task 12), add a switch statement on the incoming DPID to parse the value and call the appropriate local function (`setPumpState`, `setRgbColor`, etc.).",
			"reasoning": "This task connects the existing firmware logic to the Tuya SDK infrastructure built in Task 12. It requires modifying existing functions like `setPumpState` and the sensor reading logic in the main `loop()` to call Tuya DP reporting functions. Additionally, it involves implementing the logic inside the `dp_process` callback to parse incoming commands from the Tuya cloud and call local functions like `setPumpState` and `setRgbColor`. The complexity lies in correctly mapping all features to DPs and ensuring this two-way synchronization is robust."
		},
		{
			"taskId": 17,
			"taskTitle": "Firmware: Implement Comprehensive Safety System",
			"complexityScore": 8,
			"recommendedSubtasks": 6,
			"expansionPrompt": "Implement a multi-layered safety system. Break this down into: 1. **Watchdog:** In `src/main.cpp`, initialize `esp_task_wdt` in `setup()` and reset it in `loop()`. 2. **Pump Timeouts:** In `loop()`, track `millis()` for each active pump and call `setPumpState(false)` if a max duration is exceeded. 3. **E-Stop:** Create a global `emergencyStopActive` flag. Implement a GPIO ISR and a new WebSocket command ('emergency_stop') to set this flag and turn off all pumps. Modify `setPumpState` to prevent turning pumps ON if the flag is true. 4. **Frontend:** Add a prominent E-Stop button to `frontend/src/app/page.tsx` that sends the WebSocket command. 5. **Logging:** Create a `logAuditEvent` function and call it for all safety-related events. 6. **Health Endpoint:** Create a new `/api/health` REST endpoint to expose system metrics.",
			"reasoning": "This is a high-complexity task as it introduces multiple, critical safety layers that touch almost every part of the system. It requires implementing a hardware watchdog (`esp_task_wdt`), software timers for pump timeouts in the main `loop()`, a new GPIO interrupt for a physical E-stop button, extending the WebSocket protocol and `setPumpState` function for the E-stop logic, and adding a new audit logging mechanism. The combination of hardware-level, application-level, and UI changes makes this a complex undertaking."
		},
		{
			"taskId": 22,
			"taskTitle": "Implement First Automation Rule: Temperature-Based Heating Control",
			"complexityScore": 4,
			"recommendedSubtasks": 4,
			"expansionPrompt": "Implement a temperature-based automation rule in `firmware/src/main.cpp`. Define global variables for `targetTemperature`, `hysteresis`, and a manual override timer for the heating pump. In the main `loop()`, add a new logic block that checks if the pump is in 'AUTO' mode. If so, compare the current temperature (from the existing sensor reading) against the target and call `setPumpState` accordingly. When a manual `set_pump` command is received for this pump, set its mode to 'MANUAL' and start the override timer. Modify the `broadcastState` function to include the current mode ('AUTO'/'MANUAL') for each pump.",
			"reasoning": "The core components for this task, sensor reading (Task 3) and pump control (`setPumpState`), are already implemented. The task involves adding new state management (target temp, hysteresis, override timer) and control logic within the main `loop()` of `src/main.cpp`. The complexity is moderate as it requires creating a small state machine to handle 'AUTO' vs 'MANUAL' modes and integrating this with existing manual controls."
		},
		{
			"taskId": 18,
			"taskTitle": "Implement Core Firmware Safety Mechanisms (Watchdog, Timeouts, Failsafe)",
			"complexityScore": 5,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Break down this task with a focus on implement core firmware safety mechanisms (watchdog, timeouts, failsafe).",
			"reasoning": "Automatically added due to missing analysis in AI response."
		},
		{
			"taskId": 19,
			"taskTitle": "Integrate and Expose Sensor Data via WebSocket (DS18B20 & LDR)",
			"complexityScore": 5,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Break down this task with a focus on integrate and expose sensor data via websocket (ds18b20 & ldr).",
			"reasoning": "Automatically added due to missing analysis in AI response."
		},
		{
			"taskId": 20,
			"taskTitle": "Build Real-Time Frontend Dashboard with Shadcn/UI",
			"complexityScore": 5,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Break down this task with a focus on build real-time frontend dashboard with shadcn/ui.",
			"reasoning": "Automatically added due to missing analysis in AI response."
		},
		{
			"taskId": 21,
			"taskTitle": "Implement Emergency Stop and SPIFFS Audit Logging",
			"complexityScore": 5,
			"recommendedSubtasks": 3,
			"expansionPrompt": "Break down this task with a focus on implement emergency stop and spiffs audit logging.",
			"reasoning": "Automatically added due to missing analysis in AI response."
		}
	]
}