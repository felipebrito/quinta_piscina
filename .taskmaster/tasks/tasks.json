{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Firmware: Implement Relay Control Logic and WebSocket Handler",
        "description": "Implement the core logic in the ESP32 firmware to control the 4 relays (pumps) based on commands received via WebSocket. This involves parsing incoming JSON messages and toggling the corresponding GPIO pins.",
        "details": "Define a JSON message format, e.g., `{\"action\": \"set_pump\", \"pump_id\": <0-3>, \"state\": <true/false>}`. In the WebSocket event handler, parse this JSON. Create a function `setPumpState(pumpId, state)` that sets the `digitalWrite` for the correct GPIO pin. Ensure GPIO pins are configured as outputs in `setup()`.",
        "testStrategy": "Use a WebSocket client (like Postman or a simple web page) to send control messages to the ESP32. Verify with an LED connected to each relay's GPIO pin or by listening for the click of the physical relays.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Relay GPIO Pins and Initialize in setup()",
            "description": "Define an array in `src/main.cpp` to map the four pump IDs (0-3) to their corresponding ESP32 GPIO pins. Then, in the `setup()` function, iterate through this array to configure each pin as an output using `pinMode()`.",
            "dependencies": [],
            "details": "Near the top of `src/main.cpp`, add a global constant array, for example: `const int PUMP_PINS[4] = {23, 22, 21, 19};`. In the `setup()` function, add a `for` loop to call `pinMode(PUMP_PINS[i], OUTPUT);` and `digitalWrite(PUMP_PINS[i], LOW);` for each pin to ensure they start in the 'off' state.\n<info added on 2025-09-18T02:05:03.787Z>\n[\n  4\n]\n</info added on 2025-09-18T02:05:03.787Z>",
            "status": "done",
            "testStrategy": "After flashing, check the serial monitor for any boot errors. If possible, use a multimeter to confirm the configured GPIO pins are initialized to a LOW voltage state."
          },
          {
            "id": 2,
            "title": "Create `setPumpState()` Function for Relay Control",
            "description": "Implement a dedicated function, `void setPumpState(int pumpId, bool state)`, to abstract the logic for controlling a single relay. This function will perform input validation and execute the `digitalWrite` command.",
            "dependencies": [],
            "details": "In `src/main.cpp`, create the function `setPumpState`. It should first check if `pumpId` is within the valid range (0-3). If valid, it will use the `PUMP_PINS` array to get the correct GPIO pin and call `digitalWrite(PUMP_PINS[pumpId], state ? HIGH : LOW);`. Add `Serial.printf` statements to log the action, e.g., `Serial.printf(\"Setting pump %d to state %d\\n\", pumpId, state);`.",
            "status": "done",
            "testStrategy": "Temporarily call this function from `setup()` (e.g., `setPumpState(0, true);`) to verify that the correct relay/LED turns on upon boot."
          },
          {
            "id": 3,
            "title": "Parse Incoming JSON in WebSocket Event Handler",
            "description": "Within the existing `onWebSocketEvent` function in `src/main.cpp`, implement the logic to handle incoming data messages (`WS_EVT_DATA`). Use the `ArduinoJson` library to parse the received byte array into a JSON document.",
            "dependencies": [],
            "details": "Inside the `if (type == WS_EVT_DATA)` block, declare a `StaticJsonDocument` with an appropriate size (e.g., 256 bytes). Use `deserializeJson(doc, data, len)` to parse the payload. Add error handling to check the return value of `deserializeJson` and log any parsing failures to the Serial monitor.",
            "status": "done",
            "testStrategy": "Use a WebSocket client to send various valid and invalid JSON strings to the ESP32's `/ws` endpoint. Monitor the serial output to confirm that valid JSON is parsed without error and invalid JSON is correctly identified and logged."
          },
          {
            "id": 4,
            "title": "Implement 'set_pump' Action Dispatcher",
            "description": "After successfully parsing an incoming JSON message, inspect the document to see if it represents a pump control command. If the `action` is `\"set_pump\"`, extract the `pump_id` and `state` and use them to call the `setPumpState` function.",
            "dependencies": [],
            "details": "Following the successful `deserializeJson` call, add a conditional check: `if (doc[\"action\"] == \"set_pump\")`. Inside this block, extract the values: `int pumpId = doc[\"pump_id\"];` and `bool pumpState = doc[\"state\"];`. Before calling `setPumpState(pumpId, pumpState);`, add checks to ensure the `pump_id` and `state` keys are not null.",
            "status": "done",
            "testStrategy": "Using a WebSocket client, send a message like `{\"action\": \"set_pump\", \"pump_id\": 1, \"state\": true}`. Verify via serial logs that the message is parsed and `setPumpState` is called with the correct arguments. Observe the physical relay or connected LED for state change."
          },
          {
            "id": 5,
            "title": "Broadcast Pump State Changes to All WebSocket Clients",
            "description": "Enhance the control logic to provide feedback. After a pump's state is changed, create a new JSON message confirming the new state and broadcast it to all connected WebSocket clients using `ws.textAll()`.",
            "dependencies": [],
            "details": "After the call to `setPumpState` in the WebSocket handler, create a new `StaticJsonDocument` for the response. Populate it with the pump's new status, e.g., `responseDoc[\"action\"] = \"pump_status\"; responseDoc[\"pump_id\"] = pumpId; responseDoc[\"state\"] = pumpState;`. Serialize this document to a string and broadcast it using `ws.textAll(outputString);`.",
            "status": "done",
            "testStrategy": "Connect two WebSocket clients. Send a `set_pump` command from one client. Verify that both clients receive the `pump_status` confirmation message and that the physical relay state matches the broadcasted state."
          }
        ]
      },
      {
        "id": 2,
        "title": "Frontend: Implement Pump Control Switches",
        "description": "Connect the Shadcn/UI Switch components on the Next.js dashboard to send control messages to the ESP32 via the existing WebSocket connection.",
        "details": "In the React component for each pump, add an `onCheckedChange` handler to the `<Switch>` element. When toggled, construct the JSON message defined in Task 1 and send it using the WebSocket instance. The UI should reflect the intended state immediately, but update to the actual state upon receiving a broadcast from the ESP32.",
        "testStrategy": "Open the web UI and toggle the switches for each pump. Verify in the browser's developer tools that the correct WebSocket messages are being sent. Confirm that the physical relays (or test LEDs) on the hardware respond as expected.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Local State to PumpCard for Optimistic Updates",
            "description": "Modify the `PumpCard.tsx` component to include a local React state using `useState` to manage the checked status of the switch. This state will be initialized from the `status` prop but will be updated immediately on user interaction to provide an optimistic UI response.",
            "dependencies": [],
            "details": "In `components/PumpCard.tsx`, import `useState` from React. Create a state variable, e.g., `const [isChecked, setIsChecked] = useState(status);`. The `checked` prop of the `<Switch>` component should be bound to this new `isChecked` state variable instead of the `status` prop directly.",
            "status": "done",
            "testStrategy": "Verify that toggling the switch visually changes its state in the UI, even without any backend connection."
          },
          {
            "id": 2,
            "title": "Expose WebSocket `sendMessage` Function via Context or Hook",
            "description": "Locate the existing WebSocket management logic (likely in a custom hook like `useWebSocket` or a React Context provider). Ensure there is a stable function available to send JSON messages to the ESP32, and that this function is exposed for use in UI components.",
            "dependencies": [],
            "details": "Analyze the existing WebSocket implementation. If it's in a context, ensure the context value provides a `sendMessage` function. If it's a hook, ensure the hook returns the `sendMessage` function. This function should accept a JavaScript object, stringify it, and send it via the WebSocket instance. The main page component (`app/page.tsx`) will consume this.",
            "status": "done",
            "testStrategy": "In `app/page.tsx`, call the `sendMessage` function with a test object and verify in the browser's developer tools that the message is sent over the WebSocket connection."
          },
          {
            "id": 3,
            "title": "Implement `onCheckedChange` Handler in `PumpCard`",
            "description": "Create the handler function for the `onCheckedChange` event on the `<Switch>` component within `PumpCard.tsx`. This function will be responsible for updating the local state and preparing the control message.",
            "dependencies": [
              "2.1"
            ],
            "details": "In `components/PumpCard.tsx`, define a function `handleCheckedChange(checked: boolean)`. Inside this function, call `setIsChecked(checked)` to update the local optimistic state. Attach this function to the `<Switch>` component: `<Switch onCheckedChange={handleCheckedChange} ... />`. The function will also need to accept a callback for sending the message, which will be added in the next step.",
            "status": "done",
            "testStrategy": "Add a `console.log` inside `handleCheckedChange` and verify that toggling the switch logs the new boolean state to the console."
          },
          {
            "id": 4,
            "title": "Connect `PumpCard` Handler to WebSocket `sendMessage`",
            "description": "Pass a function from the parent component (`app/page.tsx`) down to each `PumpCard` component as a prop. This prop will be responsible for sending the state change message. Update the `onCheckedChange` handler to call this function with the correctly formatted JSON message.",
            "dependencies": [
              "2.2",
              "2.3"
            ],
            "details": "Update the `PumpCardProps` interface to accept a new prop, e.g., `onStateChange: (pumpId: string, state: boolean) => void;`. In `app/page.tsx`, use the `sendMessage` function from the WebSocket context/hook to define the function passed to `onStateChange`. In `PumpCard.tsx`, call this prop from within `handleCheckedChange`, passing the pump's ID and the new state. The parent will then construct the final JSON `{ action: 'set_pump', ... }` and send it.",
            "status": "done",
            "testStrategy": "Toggle a pump switch in the UI. Verify in the browser's developer tools that the correct WebSocket message (e.g., `{\"action\":\"set_pump\",\"pump_id\":\"pump1\",\"state\":true}`) is sent."
          },
          {
            "id": 5,
            "title": "Synchronize `PumpCard` State with External WebSocket Data",
            "description": "Implement a `useEffect` hook in `PumpCard.tsx` to synchronize the component's local `isChecked` state with the `status` prop. This ensures that when the authoritative state is received from the ESP32 (as part of Task 5) and passed down as a prop, the UI corrects itself, completing the optimistic update loop.",
            "dependencies": [
              "2.1"
            ],
            "details": "In `components/PumpCard.tsx`, import `useEffect` from React. Add a `useEffect` hook that triggers when the `status` prop changes. Inside the effect, update the local state to match the prop: `useEffect(() => { setIsChecked(status); }, [status]);`. This ensures the component reflects the true state broadcasted from the server, overriding any temporary optimistic state.",
            "status": "done",
            "testStrategy": "While the UI is open, manually trigger a state change on the hardware (if possible). Verify that the switch on the dashboard updates to the correct state automatically without a page refresh."
          }
        ]
      },
      {
        "id": 3,
        "title": "Firmware: Implement Sensor Reading for DS18B20 and LDR",
        "description": "Write the firmware code to periodically read data from the DS18B20 temperature sensor and the LDR (Light Dependent Resistor) for luminosity.",
        "details": "Use the `DallasTemperature` and `OneWire` libraries for the DS18B20. Implement a non-blocking read function that is called periodically (e.g., every 5 seconds). For the LDR, use `analogRead` on the connected ADC pin. Map the raw analog value to a percentage (0-100%). Store the latest values in global state variables.",
        "testStrategy": "Print the read temperature and luminosity values to the Serial Monitor. Verify the temperature against a known-good thermometer. Cover and uncover the LDR to see the luminosity values change accordingly.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Sensor Pins and Global State Variables",
            "description": "In `src/main.cpp`, define the GPIO pins for the DS18B20 One-Wire bus and the LDR analog input. Also, declare the global variables that will hold the latest temperature and luminosity values.",
            "dependencies": [],
            "details": "Add `#define` directives for `ONE_WIRE_BUS` and `LDR_PIN` at the top of `src/main.cpp`. Declare two global variables, for example, `float currentTemperature = 0.0;` and `int currentLuminosity = 0;`, to store the sensor readings.",
            "status": "done",
            "testStrategy": "Compile the code to ensure there are no syntax errors after adding the definitions and variables."
          },
          {
            "id": 2,
            "title": "Initialize DS18B20 Sensor in setup()",
            "description": "In `src/main.cpp`, include the necessary libraries for the DS18B20 sensor, instantiate the library objects, and initialize the sensor in the `setup()` function.",
            "dependencies": [
              "3.1"
            ],
            "details": "Add `#include <OneWire.h>` and `#include <DallasTemperature.h>`. Create global instances: `OneWire oneWire(ONE_WIRE_BUS);` and `DallasTemperature sensors(&oneWire);`. In the `setup()` function, call `sensors.begin();` to initialize the sensor.",
            "status": "done",
            "testStrategy": "Compile the firmware. After flashing, check the serial monitor for any error messages from the `DallasTemperature` library during initialization."
          },
          {
            "id": 3,
            "title": "Implement LDR Reading and Mapping Function",
            "description": "Create a dedicated function in `src/main.cpp` to read the analog value from the LDR pin and map it to a 0-100% luminosity scale.",
            "dependencies": [
              "3.1"
            ],
            "details": "Create a function `void updateLuminosity()`. Inside this function, use `analogRead(LDR_PIN)` to get the raw value. Since the ESP32 ADC is 12-bit, map the result from the 0-4095 range to a 0-100 integer range using the `map()` function. Store the result in the `currentLuminosity` global variable.",
            "status": "done",
            "testStrategy": "Temporarily call this function in the main loop with a `Serial.println` to verify that covering and uncovering the LDR produces changing values in the expected 0-100 range."
          },
          {
            "id": 4,
            "title": "Implement DS18B20 Temperature Reading Function",
            "description": "Create a dedicated function in `src/main.cpp` to request the temperature from the DS18B20 sensor and update the global state.",
            "dependencies": [
              "3.2"
            ],
            "details": "Create a function `void updateTemperature()`. Inside, call `sensors.requestTemperatures();` followed by `sensors.getTempCByIndex(0);`. Check the returned value against `DEVICE_DISCONNECTED_C` to handle read errors. If the read is successful, update the `currentTemperature` global variable.",
            "status": "done",
            "testStrategy": "Temporarily call this function in the main loop with a `Serial.println` to verify it prints a valid temperature reading."
          },
          {
            "id": 5,
            "title": "Create Periodic Timer to Trigger Sensor Reads",
            "description": "In the main `loop()` function, implement a non-blocking timer using `millis()` to call the sensor reading functions periodically.",
            "dependencies": [
              "3.3",
              "3.4"
            ],
            "details": "In `src/main.cpp`, add global variables `unsigned long lastSensorReadTime = 0;` and `const long sensorReadInterval = 5000;`. In the `loop()` function, add a condition `if (millis() - lastSensorReadTime >= sensorReadInterval)`. Inside this block, update `lastSensorReadTime`, call `updateTemperature()` and `updateLuminosity()`, and print the `currentTemperature` and `currentLuminosity` values to the Serial Monitor for verification.",
            "status": "done",
            "testStrategy": "Flash the firmware and monitor the serial output. Confirm that new temperature and luminosity values are printed approximately every 5 seconds."
          }
        ]
      },
      {
        "id": 4,
        "title": "Firmware: Broadcast Full Device State via WebSocket",
        "description": "Create a function to gather the current state of all pumps and sensors, format it into a single JSON object, and broadcast it to all connected WebSocket clients periodically.",
        "details": "Define a comprehensive JSON structure for the device state, e.g., `{\"pumps\": [true, false, false, true], \"sensors\": {\"temperature\": 25.5, \"luminosity\": 80}}`. Implement a timer (e.g., using `millis()`) to trigger this broadcast every 2-3 seconds.",
        "testStrategy": "Connect a WebSocket client and observe the stream of incoming state messages. Verify that the data accurately reflects the current status of the relays and the values being read from the sensors.",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement State-Gathering Functions for Pumps and Sensors",
            "description": "Create dedicated helper functions to read the current state of all pump relays and the latest values from the temperature and luminosity sensors. This centralizes data collection before formatting.",
            "dependencies": [],
            "details": "In `src/main.cpp`, create a function `void getPumpStates(bool states[], int count)` that reads the digital state of each pump pin into the provided array. Also, create a function `void getSensorReadings(float &temperature, int &luminosity)` that performs readings from the connected sensors and updates the referenced variables. These functions will abstract the hardware interaction.",
            "status": "done",
            "testStrategy": "Call these functions from the `loop()` and print their output to the Serial monitor to verify they are reading correct values from the hardware."
          },
          {
            "id": 2,
            "title": "Create JSON Serialization Function for Device State",
            "description": "Using the ArduinoJson library, implement a function that takes the collected pump and sensor data, formats it into the specified JSON structure, and returns it as a string.",
            "dependencies": [
              "4.1"
            ],
            "details": "In `src/main.cpp`, create a function `String buildStateJson()`. This function will first call `getPumpStates()` and `getSensorReadings()`. It will then use a `StaticJsonDocument` to build a JSON object with a 'pumps' array and a 'sensors' nested object. Finally, it will use `serializeJson()` to convert the document into a `String` for broadcasting. Ensure `ArduinoJson` is a dependency in `platformio.ini`.",
            "status": "done",
            "testStrategy": "Call `buildStateJson()` from `setup()` and print the resulting string to the Serial monitor. Verify the structure and values are correct."
          },
          {
            "id": 3,
            "title": "Implement Non-Blocking Timer in Main Loop",
            "description": "Add the necessary variables and logic to the main `loop()` function to create a non-blocking timer using the `millis()` function. This timer will control the frequency of the state broadcasts.",
            "dependencies": [],
            "details": "In `src/main.cpp`, declare a global `unsigned long lastStateBroadcastTime = 0;` and a constant `const long stateBroadcastInterval = 2500;` (for 2.5 seconds). In the `loop()` function, add an `if (millis() - lastStateBroadcastTime >= stateBroadcastInterval)` block and update `lastStateBroadcastTime = millis();` inside it.",
            "status": "done",
            "testStrategy": "Add a `Serial.println(\"Timer fired\");` inside the `if` block and monitor the serial output to confirm it prints at the expected interval without halting other operations."
          },
          {
            "id": 4,
            "title": "Create a Generic WebSocket Broadcast Function",
            "description": "Implement a function that encapsulates the logic for broadcasting a message to all connected WebSocket clients. This function will be called by the timer.",
            "dependencies": [
              "4.2"
            ],
            "details": "In `src/main.cpp`, create a function `void broadcastFullState()`. This function will call `buildStateJson()` to get the latest state as a string. It will then use the existing `AsyncWebSocket` instance (e.g., `ws`) to send this string to all clients using `ws.textAll(stateJsonString);`. Add a log message to indicate a broadcast has occurred.",
            "status": "done",
            "testStrategy": "Temporarily call `broadcastFullState()` when a new WebSocket client connects to verify that a single state message is sent and received correctly."
          },
          {
            "id": 5,
            "title": "Integrate Broadcast Function with Timer in Main Loop",
            "description": "Connect the periodic timer to the broadcast function to enable automatic, recurring state updates to all WebSocket clients.",
            "dependencies": [
              "4.3",
              "4.4"
            ],
            "details": "In the main `loop()` function within `src/main.cpp`, place a call to the `broadcastFullState()` function inside the `if` block of the non-blocking timer created in subtask 4.3. This will trigger the state gathering, JSON serialization, and broadcast every 2.5 seconds.",
            "status": "done",
            "testStrategy": "Connect a WebSocket client (e.g., using a browser-based tool) and observe the console. Verify that a complete JSON state message is received every 2-3 seconds and that the values update when a pump is manually toggled or sensor values change."
          }
        ]
      },
      {
        "id": 5,
        "title": "Frontend: Display Real-time Sensor Data and Pump Status",
        "description": "Update the Next.js dashboard to parse the device state messages from the WebSocket and display the data in real-time. The UI should accurately reflect the true state of the hardware.",
        "details": "In the main dashboard component, add a WebSocket `onmessage` handler. Parse the incoming JSON state object. Use React state (`useState`) to store the pump and sensor data. Bind this state to the UI elements (e.g., the `checked` prop of Switches, text fields for sensor values).",
        "testStrategy": "Load the web UI. Manually change the state of a pump (if possible) or change sensor conditions (e.g., heat the temperature sensor). Verify that the dashboard updates automatically within a few seconds without a page refresh.",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add React State for Sensor and Light Data",
            "description": "In `src/app/page.tsx`, introduce `useState` hooks to manage the state for water temperature, pH level, and light status. Initialize them with default values like `null` or placeholder strings to be displayed before the first message is received.",
            "dependencies": [],
            "details": "In the `Dashboard` component, add the following states: `const [temperature, setTemperature] = useState<number | null>(null);`, `const [phLevel, setPhLevel] = useState<number | null>(null);`, and `const [lightStatus, setLightStatus] = useState({ on: false, color: 'N/A' });`. These will hold the real-time data received from the WebSocket.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement WebSocket `onmessage` Handler",
            "description": "In the `useEffect` hook within `src/app/page.tsx`, attach an `onmessage` event handler to the `websocket` instance. This handler will be the entry point for processing all incoming state updates from the ESP32.",
            "dependencies": [],
            "details": "Inside the `useEffect` where the `WebSocket` is instantiated, add the `onmessage` property: `websocket.onmessage = (event) => { ... };`. The logic for parsing and state updates will be placed inside this function in subsequent tasks.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Parse Incoming JSON Data in `onmessage` Handler",
            "description": "Within the `onmessage` handler, parse the incoming `event.data` string as JSON. Implement error handling using a `try...catch` block to prevent the application from crashing due to malformed messages and log any errors.",
            "dependencies": [
              "5.2"
            ],
            "details": "Inside the `onmessage` handler, implement the parsing logic: `try { const data = JSON.parse(event.data); /* process data */ } catch (error) { console.error('Failed to parse WebSocket message:', event.data, error); }`. This ensures robust handling of incoming data.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Update Pump and Sensor State from Parsed Data",
            "description": "Inside the `try` block of the `onmessage` handler, after successfully parsing the JSON, check for expected keys (`pumps`, `temperature`, `ph`, `light`) in the data object. Use the corresponding state setters (`setPumps`, `setTemperature`, etc.) to update the component's state.",
            "dependencies": [
              "5.1",
              "5.3"
            ],
            "details": "Add logic to update state based on the received data structure, e.g., `if (data.pumps) { setPumps(data.pumps); }`, `if (data.temperature !== undefined) { setTemperature(data.temperature); }`, `if (data.ph !== undefined) { setPhLevel(data.ph); }`, `if (data.light) { setLightStatus(data.light); }`.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Bind Sensor and Light State to UI Elements",
            "description": "Modify the JSX in `src/app/page.tsx` to display the values from the new state variables for temperature, pH, and light status. Replace the static placeholder text with dynamic data, providing a fallback for initial `null` values.",
            "dependencies": [
              "5.1"
            ],
            "details": "Update the sensor `CardContent` divs. For example, replace `<div className=\"text-2xl font-bold\">-- °C</div>` with `<div className=\"text-2xl font-bold\">{temperature !== null ? `${temperature.toFixed(1)} °C` : '-- °C'}</div>`. Do the same for pH and light status cards.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Firmware: Persist Pump States in Non-Volatile Storage (NVS)",
        "description": "Implement logic to save the last known state of the pumps to the ESP32's NVS. The states should be restored upon device startup to handle power outages.",
        "details": "Use the `Preferences` library. In `setup()`, read the saved pump states from NVS and apply them. After every successful pump state change, write the new state array to NVS.",
        "testStrategy": "Set some pumps to 'on' via the UI. Power cycle the ESP32. Verify that upon restart, the pumps return to the 'on' state and the UI reflects this correctly after connecting.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Include Preferences Library and Initialize Object",
            "description": "Add the necessary include directive for the `Preferences.h` library and create a global instance of the `Preferences` class in `src/main.cpp` to be used for NVS operations.",
            "dependencies": [],
            "details": "In `src/main.cpp`, add `#include <Preferences.h>`. Then, declare a global object: `Preferences preferences;`. This object will provide the interface for reading from and writing to NVS.",
            "status": "done",
            "testStrategy": "Compile the firmware to ensure the new header is found and the object is instantiated without errors."
          },
          {
            "id": 2,
            "title": "Implement `savePumpStates()` Function",
            "description": "Create a new function, `void savePumpStates()`, that saves the entire `pumpStates` boolean array to NVS using the `Preferences` library.",
            "dependencies": [
              "6.1"
            ],
            "details": "The function should call `preferences.begin(\"pump-states\", false)` to open the NVS namespace. Use `preferences.putBytes(\"states\", pumpStates, sizeof(pumpStates))` to store the array. Finally, call `preferences.end()`. Use a unique key like `\"pump-states\"` for the namespace and `\"states\"` for the data.",
            "status": "done",
            "testStrategy": "Temporarily call this function from `setup()` and check serial output for any errors. Use a separate test sketch to verify that data is being written to the specified NVS key."
          },
          {
            "id": 3,
            "title": "Integrate State Saving into `setPumpState`",
            "description": "Modify the existing `setPumpState` function in `src/main.cpp` to call the new `savePumpStates()` function after a pump's state has been successfully updated.",
            "dependencies": [
              "6.2"
            ],
            "details": "In `src/main.cpp`, locate the `setPumpState(int pumpIndex, bool state)` function. After the line `digitalWrite(PUMP_PINS[pumpIndex], state ? HIGH : LOW);`, add a call to `savePumpStates();`. This ensures that every manual state change is immediately persisted.",
            "status": "done",
            "testStrategy": "Use the web UI to toggle a pump. Monitor the serial output to confirm that the `savePumpStates` function is called and executes without error after the pump state is changed."
          },
          {
            "id": 4,
            "title": "Implement State Restoration Logic in `setup()`",
            "description": "In the `setup()` function, add logic to read the saved pump states from NVS and populate the global `pumpStates` array. This should happen before the pump pins are configured.",
            "dependencies": [
              "6.1"
            ],
            "details": "In `setup()`, before the `for` loop that initializes pump pins, call `preferences.begin(\"pump-states\", true)` to open the namespace in read-only mode. Check if the `\"states\"` key exists using `preferences.isKey(\"states\")`. If it does, use `preferences.getBytes(\"states\", pumpStates, sizeof(pumpStates))` to load the data into the `pumpStates` array. Call `preferences.end()` afterwards.",
            "status": "done",
            "testStrategy": "Add serial print statements to show whether states were loaded from NVS or if the default state is being used. After performing subtask 3, restart the device and verify the logs show that states were successfully loaded."
          },
          {
            "id": 5,
            "title": "Apply Restored States to GPIO Pins on Startup",
            "description": "Modify the GPIO initialization loop in `setup()` to set the physical state of each pump's pin according to the value loaded into the `pumpStates` array.",
            "dependencies": [
              "6.4"
            ],
            "details": "Locate the `for` loop in `setup()` that iterates through `PUMP_PINS`. Change the line `digitalWrite(PUMP_PINS[i], LOW);` to `digitalWrite(PUMP_PINS[i], pumpStates[i] ? HIGH : LOW);`. This will ensure the physical relays match the restored state immediately upon boot.",
            "status": "done",
            "testStrategy": "Set several pumps to ON via the UI. Power cycle the ESP32. Observe the physical relays (or connected LEDs) to confirm they turn on at startup, corresponding to the last saved state."
          }
        ]
      },
      {
        "id": 7,
        "title": "Firmware: Implement REST API for Schedule Management",
        "description": "Create REST endpoints on the ESP32's web server to allow creating, reading, and deleting schedules. Schedules should be stored in the SPIFFS/LittleFS filesystem.",
        "details": "Use the `AsyncWebServer` and `ArduinoJson` libraries. Define endpoints: `GET /api/schedules` to list all, `POST /api/schedules` to add a new one, and `DELETE /api/schedules/{id}` to remove one. Store schedules as a JSON array in a file (e.g., `/schedules.json`).",
        "testStrategy": "Use Postman to send HTTP requests to the ESP32's IP address. Test creating a schedule (POST), verifying it's listed (GET), and then deleting it (DELETE). Check the serial logs for errors.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Filesystem Helpers for Schedule JSON",
            "description": "Implement helper functions to read from and write to the `/schedules.json` file in the SPIFFS/LittleFS filesystem. This will encapsulate file I/O and JSON parsing logic.",
            "dependencies": [],
            "details": "Create two functions: `DynamicJsonDocument readSchedules()` and `bool writeSchedules(const DynamicJsonDocument& doc)`. The `readSchedules` function should open `/schedules.json`, deserialize it into a `DynamicJsonDocument`, and return it. If the file doesn't exist, it should return a document containing an empty JSON array `[]`. The `writeSchedules` function should serialize the provided document and write it to the file, overwriting the existing content.",
            "status": "done",
            "testStrategy": "Write a temporary test function in `setup()` to call `writeSchedules` with a sample JSON array, then call `readSchedules` and print the result to the Serial monitor to verify the content is read back correctly."
          },
          {
            "id": 2,
            "title": "Implement GET /api/schedules Endpoint",
            "description": "Create the `AsyncWebServer` handler to list all existing schedules.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement a handler function for the `GET /api/schedules` route. This function will call the `readSchedules()` helper. It will then serialize the resulting `JsonDocument` into a string and send it as the response with a 200 OK status and a `Content-Type` of `application/json`.",
            "status": "done",
            "testStrategy": "After flashing, use a web browser or Postman to send a GET request to `http://<ESP32_IP>/api/schedules`. Verify it returns an empty array `[]` initially."
          },
          {
            "id": 3,
            "title": "Implement POST /api/schedules Endpoint",
            "description": "Create the `AsyncWebServer` handler to add a new schedule. This involves parsing the request body and updating the schedules file.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement a handler for `POST /api/schedules` using `onRequestBody`. Inside the handler, parse the incoming request body (which is a JSON object for the new schedule) using `ArduinoJson`. Generate a unique ID for the new schedule (e.g., using `millis()`). Call `readSchedules()` to get the current array, add the new schedule object to the `JsonArray`, and then use `writeSchedules()` to save the updated array back to the filesystem. Respond with 201 Created and the newly created schedule object.",
            "status": "done",
            "testStrategy": "Use Postman to send a POST request to `http://<ESP32_IP>/api/schedules` with a JSON body like `{\"name\":\"Morning Pump\",\"hour\":8,\"minute\":30,\"duration\":5}`. Then, use the GET endpoint to verify the new schedule was added with a unique ID."
          },
          {
            "id": 4,
            "title": "Implement DELETE /api/schedules/{id} Endpoint",
            "description": "Create the `AsyncWebServer` handler to remove a specific schedule by its ID.",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement a handler for `DELETE /api/schedules/{id}`. The URL will contain a placeholder for the ID. Extract the `id` from the request placeholders. Call `readSchedules()`, iterate through the `JsonArray` to find the object with the matching `id`, and remove it. Use `writeSchedules()` to save the modified array. Respond with 204 No Content on success or 404 Not Found if the ID doesn't exist.",
            "status": "done",
            "testStrategy": "First, create a schedule using the POST endpoint. Note its ID. Then, send a DELETE request to `http://<ESP32_IP>/api/schedules/<ID>`. Finally, use the GET endpoint to confirm the schedule has been removed."
          },
          {
            "id": 5,
            "title": "Register New API Handlers with AsyncWebServer",
            "description": "Integrate the newly created REST endpoint handlers into the main web server configuration.",
            "dependencies": [
              "7.2",
              "7.3",
              "7.4"
            ],
            "details": "In the primary firmware file (e.g., `ESP32-Tuya.ino` or `main.cpp`), locate the web server setup section. Add the `server.on()` calls to register the handlers for `GET /api/schedules`, `POST /api/schedules`, and `DELETE /api/schedules/{id}` with the global `AsyncWebServer` instance. Ensure the POST handler is correctly configured to process a JSON body.",
            "status": "done",
            "testStrategy": "After flashing the complete firmware, perform an end-to-end test: create a schedule (POST), list all schedules to see it (GET), delete it (DELETE), and list them again to confirm it's gone. Monitor serial output for any errors during the process."
          }
        ]
      },
      {
        "id": 8,
        "title": "Firmware: Implement Scheduling Engine",
        "description": "Develop the core logic that processes the stored schedules. This requires time synchronization via NTP and checking the current time against schedule entries to automate pump control.",
        "details": "In `setup()`, initialize NTP to get the current time. In the main `loop()`, periodically check the current time. Iterate through the loaded schedules. If the current time falls within a schedule's active window, call the `setPumpState` function. Ensure this logic co-exists with manual control.",
        "testStrategy": "Create a schedule via the API that starts in 1-2 minutes. Monitor the serial output and the physical relay to confirm the pump turns on at the correct time and turns off when the schedule ends.",
        "priority": "high",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize NTP Client for Time Synchronization",
            "description": "In `src/main.cpp`, include the necessary time libraries and configure the NTP client. In the `setup()` function, initialize the connection to an NTP server to fetch and synchronize the current UTC time. Set the correct timezone for local time calculation.",
            "dependencies": [],
            "details": "Add `#include <time.h>` and related libraries. Use `configTime()` to set the GMT offset, daylight saving offset, and NTP server address (e.g., 'pool.ntp.org'). Add serial print statements to confirm successful time synchronization or log failures during startup.",
            "status": "pending",
            "testStrategy": "Monitor the serial output on boot. Verify that the ESP32 successfully connects to the NTP server and prints the correct current date and time."
          },
          {
            "id": 2,
            "title": "Create a Time Structure and Current Time Getter",
            "description": "In `src/main.cpp`, define a function `getCurrentTimeInfo()` that populates a `struct tm` object with the current local time. This function will be the primary source of time for the scheduling engine and should be called periodically.",
            "dependencies": [
              "8.1"
            ],
            "details": "Create a function `bool getCurrentTimeInfo(struct tm &timeinfo)` that calls `getLocalTime(&timeinfo)`. This encapsulates the time-fetching logic. Ensure it handles the case where time is not yet synchronized. The function should return `true` on success.",
            "status": "pending",
            "testStrategy": "Call the new function from the main loop and print the formatted day of the week, hour, and minute to the serial monitor to verify it's providing correct and updated time information."
          },
          {
            "id": 3,
            "title": "Implement Core Schedule Evaluation Logic",
            "description": "Create a new function, `void processSchedules()`, that iterates through the global `schedules` vector (loaded from `storage.h`). For each enabled schedule, it will compare the current time (obtained via `getCurrentTimeInfo`) with the schedule's start time and duration to determine if the pump should be active.",
            "dependencies": [
              "8.2"
            ],
            "details": "Inside `processSchedules()`, get the current time. Loop through `extern std::vector<Schedule> schedules;`. For an enabled schedule matching the current day of the week, calculate the total minutes from midnight for the current time, the schedule start time, and the schedule end time (`startHour * 60 + startMinute + durationMinutes`). Determine if the current time falls within this window. A flag should be set if any schedule requires the pump to be on.",
            "status": "pending",
            "testStrategy": "Manually create a test `Schedule` object in code. Call `processSchedules()` and use serial prints to log whether the function correctly identifies that the current time is inside or outside the test schedule's window."
          },
          {
            "id": 4,
            "title": "Integrate Scheduler with Pump Control and Manual Override",
            "description": "Modify the `processSchedules` function to call `setPumpState()` based on its evaluation. Implement a manual override mechanism to prevent the scheduler from immediately overriding a user's manual pump control action.",
            "dependencies": [
              "8.3"
            ],
            "details": "Define a global variable `unsigned long lastManualControlTime = 0;`. Update this timestamp whenever a manual control command is received (e.g., via WebSocket). In `processSchedules`, before calling `setPumpState()`, check if `millis() - lastManualControlTime` is less than a defined override period (e.g., 15 minutes). If it is, the scheduler should not change the pump state. The final logic should be: if no schedule is active, turn the pump off; if at least one schedule is active, turn it on, respecting the manual override.",
            "status": "pending",
            "testStrategy": "1. Set a schedule. Let it turn the pump on. 2. Manually turn the pump off via the web UI. Verify the scheduler does not turn it back on for the duration of the override period. 3. After the period expires, verify the scheduler resumes control and turns the pump on."
          },
          {
            "id": 5,
            "title": "Add Periodic Execution to Main Loop",
            "description": "In the main `loop()` function in `src/main.cpp`, add non-blocking timer logic using `millis()` to call the `processSchedules()` function at a regular interval, such as every 10 seconds.",
            "dependencies": [
              "8.4"
            ],
            "details": "Declare a global `unsigned long lastScheduleCheck = 0;` and a constant `const long scheduleCheckInterval = 10000;`. In `loop()`, add the standard `if (millis() - lastScheduleCheck >= scheduleCheckInterval)` block to call `processSchedules()` and update `lastScheduleCheck`. This ensures the scheduling logic runs periodically without blocking other operations like the web server.",
            "status": "pending",
            "testStrategy": "Add a serial print statement inside the `if` block that triggers the schedule check. Monitor the serial output to confirm that the message is printed approximately every 10 seconds and that the rest of the application (like web UI) remains responsive."
          }
        ]
      },
      {
        "id": 9,
        "title": "Frontend: Create Schedule Management UI",
        "description": "Build a new page or modal in the Next.js application to manage schedules. The UI should allow users to view, create, and delete schedules by interacting with the ESP32's REST API.",
        "details": "Use Shadcn/UI components like `<Table>`, `<Dialog>`, `<form>`, and `<TimePicker>` (or equivalent input) to build the interface. Fetch existing schedules on component mount. Implement form submission to POST new schedules and button clicks to send DELETE requests.",
        "testStrategy": "Navigate to the new scheduling UI. Create a schedule for a specific pump and time. Verify the schedule appears in the list. Delete the schedule and confirm it is removed from the list. Verify the ESP32 hardware responds to the created schedule.",
        "priority": "high",
        "dependencies": [
          5,
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create New Schedule Page and Define Data Types",
            "description": "Create a new route and page file at `app/schedules/page.tsx`. Set up the basic page layout with a main heading. Define the TypeScript interface for a `Schedule` object based on the expected API response (e.g., id, pump, hour, minute, action).",
            "dependencies": [],
            "details": "Create the file `app/schedules/page.tsx`. This file will serve as the main container for the schedule management UI. Inside this file, or in a shared types file, define `type Schedule = { id: number; pump: number; hour: number; minute: number; action: 'ON' | 'OFF'; };`. The page should have a simple layout, perhaps using a `<Card>` component for structure, with a `<h1>` title like 'Schedule Management'.",
            "status": "pending",
            "testStrategy": "Navigate to the `/schedules` URL in the browser and verify the new page loads with the correct title. Check that the TypeScript type definition for `Schedule` is created without errors."
          },
          {
            "id": 2,
            "title": "Implement Schedule Table Component for Viewing Schedules",
            "description": "Create a component that fetches existing schedules from the ESP32's `/api/schedules` endpoint and displays them in a Shadcn/UI `<Table>`. The table should include columns for Pump, Time, Action, and a placeholder for delete actions.",
            "dependencies": [
              "9.1"
            ],
            "details": "In a new component file, e.g., `components/schedule-table.tsx`, use `useEffect` to fetch data from `/api/schedules` on component mount. Use `useState` to store the array of schedules. Render the data using Shadcn's `<Table>`, `<TableHeader>`, `<TableRow>`, `<TableHead>`, and `<TableBody>` components. Format the time from the `hour` and `minute` fields into a user-friendly `HH:MM` string.",
            "status": "pending",
            "testStrategy": "Load the `/schedules` page. Verify the component makes a GET request to `/api/schedules`. Mock or ensure the ESP32 returns a list of schedules and confirm they are displayed correctly in the table."
          },
          {
            "id": 3,
            "title": "Build 'Add Schedule' Dialog with Form",
            "description": "Create a new component that uses Shadcn's `<Dialog>` to present a form for creating a new schedule. The form should include inputs for selecting a pump, setting a time, and choosing an action (ON/OFF).",
            "dependencies": [
              "9.1"
            ],
            "details": "Create an `AddScheduleDialog` component. Use `<DialogTrigger>` with a `<Button>` on the main schedules page to open it. The form inside the dialog should use Shadcn's `<Form>`, `<FormField>`, `<Input type='time'>` (or two separate number inputs for hour/minute), and `<Select>` for choosing the pump (e.g., Pump 1-4) and action ('ON'/'OFF'). Use `react-hook-form` for form state management, following existing patterns if available.",
            "status": "pending",
            "testStrategy": "On the `/schedules` page, click the 'Add Schedule' button. Verify the dialog opens with the correct form fields. Test that the form inputs can be filled out and that basic validation (if any) works."
          },
          {
            "id": 4,
            "title": "Implement Form Submission Logic to Create Schedules (POST)",
            "description": "Add the submission handler to the 'Add Schedule' form. This function will send a POST request with the new schedule data to the ESP32's `/api/schedules` endpoint. On success, it should close the dialog and refresh the schedule list.",
            "dependencies": [
              "9.2",
              "9.3"
            ],
            "details": "Implement the `onSubmit` function for the form created in the previous subtask. The function should construct a JSON object matching the API's expected format. Use the `fetch` API to send a POST request to `/api/schedules`. After a successful response, trigger a re-fetch of the schedule list in the `ScheduleTable` component to display the newly added schedule.",
            "status": "pending",
            "testStrategy": "Fill out and submit the 'Add Schedule' form. Use browser developer tools to verify a POST request is sent to `/api/schedules` with the correct JSON payload. Confirm the schedule table updates to show the new entry."
          },
          {
            "id": 5,
            "title": "Implement Schedule Deletion Logic (DELETE)",
            "description": "Add a delete button to each row of the schedule table. When clicked, this button should send a DELETE request to the ESP32's API for that specific schedule ID and update the UI to remove the corresponding row.",
            "dependencies": [
              "9.2"
            ],
            "details": "In the `ScheduleTable` component, add a new `<TableCell>` to each row containing a `<Button>` with a trash icon. Create a handler function that takes the schedule `id` as an argument. This handler will use `fetch` to send a DELETE request to an endpoint like `/api/schedules?id=<schedule_id>`. Upon successful deletion, refresh the schedule list to remove the item from the view.",
            "status": "pending",
            "testStrategy": "Click the delete button for a schedule in the table. Verify in the developer tools that a DELETE request is sent with the correct schedule ID. Confirm the row is removed from the table on the UI."
          }
        ]
      },
      {
        "id": 10,
        "title": "Firmware: Implement RGB LED PWM Control",
        "description": "Implement the firmware logic to control the RGB lighting using the ESP32's LEDC (PWM) peripheral. Create a function and a WebSocket/REST endpoint to set the color.",
        "details": "Configure three LEDC channels for R, G, and B pins in `setup()`. Create a function `setRgbColor(r, g, b)` that uses `ledcWrite()` to set the duty cycle for each channel. Expose this function via a WebSocket command `{\"action\": \"set_rgb\", \"color\": {\"r\": 255, \"g\": 100, \"b\": 50}}`.",
        "testStrategy": "Connect an RGB LED to the configured GPIO pins. Send WebSocket commands with different RGB values and verify that the LED changes to the correct color.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define RGB Pin and LEDC Constants",
            "description": "In `src/main.cpp`, define the GPIO pins for the Red, Green, and Blue LED channels. Also, define constants for the LEDC peripheral, including frequency, resolution, and channel indices for each color.",
            "dependencies": [],
            "details": "Add `#define` statements at the top of `src/main.cpp` for `RGB_R_PIN`, `RGB_G_PIN`, and `RGB_B_PIN`. Define constants for LEDC parameters like `LEDC_FREQ`, `LEDC_RESOLUTION`, `LEDC_R_CHANNEL`, `LEDC_G_CHANNEL`, and `LEDC_B_CHANNEL` to keep the configuration organized and easy to modify.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Initialize LEDC Channels in setup()",
            "description": "In the `setup()` function within `src/main.cpp`, configure the three LEDC channels for PWM control of the RGB LED. This involves setting up the timer and attaching the GPIO pins to their respective channels.",
            "dependencies": [
              "10.1"
            ],
            "details": "Use `ledcSetup()` for each channel (R, G, B) with the defined frequency and resolution. Then, use `ledcAttachPin()` to associate each configured GPIO pin with its corresponding LEDC channel. This should be done in the pin configuration section of the `setup()` function.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create setRgbColor(r, g, b) Function",
            "description": "Implement a new function, `void setRgbColor(uint8_t r, uint8_t g, uint8_t b)`, in `src/main.cpp`. This function will take 8-bit red, green, and blue values and set the corresponding duty cycle on each LEDC channel.",
            "dependencies": [
              "10.2"
            ],
            "details": "The function should use `ledcWrite()` for each of the three channels (`LEDC_R_CHANNEL`, `LEDC_G_CHANNEL`, `LEDC_B_CHANNEL`) to set the duty cycle based on the input `r`, `g`, and `b` values. The values are 0-255, which matches the 8-bit resolution defined in subtask 10.1.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Handle 'set_rgb' WebSocket Command",
            "description": "Modify the `webSocketEvent` function in `src/main.cpp` to handle a new WebSocket command for setting the RGB color. Parse the incoming JSON and call the `setRgbColor` function.",
            "dependencies": [
              "10.3"
            ],
            "details": "Add a new `else if` block to check for `action == \"set_rgb\"`. Inside this block, use ArduinoJson to parse the nested `color` object from the payload (e.g., `doc[\"color\"][\"r\"]`). Extract the r, g, and b values and pass them to the `setRgbColor()` function. Add error handling for missing color values.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Set Initial LED State on Boot",
            "description": "Ensure the RGB LED is in a known state (off) when the device boots up. Call the `setRgbColor` function at the end of the `setup()` function in `src/main.cpp`.",
            "dependencies": [
              "10.3"
            ],
            "details": "After all initializations in `setup()` are complete, add a call to `setRgbColor(0, 0, 0);` to turn the RGB LED off. This prevents the LED from being in a random or floating state on power-up.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Frontend: Add RGB Color Picker to Dashboard",
        "description": "Integrate a color picker component into the dashboard UI to allow users to select a color for the pool lighting and send the command to the ESP32.",
        "details": "Add a library like `react-color`. Place the color picker in a `<Popover>` triggered by a button. On color change, send the RGB value to the ESP32 using the WebSocket command defined in the previous task. The UI should also display the current color broadcasted from the ESP32 state.",
        "testStrategy": "Open the UI and use the color picker. Verify the physical RGB LED changes color in real-time as you select different hues. Verify the color picker updates if the color is changed by another means.",
        "priority": "medium",
        "dependencies": [
          5,
          10
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install react-color and Create Color Control Component File",
            "description": "Add the `react-color` library and its corresponding type definitions to the project's dependencies. Create a new component file to house the color picker logic.",
            "dependencies": [],
            "details": "Run `npm install react-color` and `npm install -D @types/react-color`. Create a new file at `src/components/controls/ColorPickerControl.tsx`. This file will contain the React component for the color picker functionality.",
            "status": "done",
            "testStrategy": "Verify that the dependencies are added to `package.json` and the new component file is created in the specified directory without causing any build errors."
          },
          {
            "id": 2,
            "title": "Implement Popover UI with Shadcn/UI and react-color",
            "description": "Build the user interface for the color picker using a Shadcn/UI Popover. The Popover will be triggered by a Button and will contain a color picker from the `react-color` library.",
            "dependencies": [
              "11.1"
            ],
            "details": "In `src/components/controls/ColorPickerControl.tsx`, use Shadcn/UI components: `<Popover>`, `<PopoverTrigger>`, and `<PopoverContent>`. The trigger will be a `<Button>`. Inside the `<PopoverContent>`, render a color picker component from `react-color`, such as `<SketchPicker />`. Initially, this will be a static layout without state logic.",
            "status": "done",
            "testStrategy": "Load the dashboard page where the component is temporarily placed. Verify that a button is visible and clicking it opens a popover containing the color picker."
          },
          {
            "id": 3,
            "title": "Send Color Change Commands via WebSocket",
            "description": "Implement the logic to send a WebSocket command to the ESP32 whenever the user selects a new color in the picker.",
            "dependencies": [
              "11.2"
            ],
            "details": "In `ColorPickerControl.tsx`, use the existing WebSocket context/hook (similar to the pump switches). Add an `onChangeComplete` handler to the `<SketchPicker />` component. Inside the handler, format the selected color into the required JSON message (e.g., `{ \"command\": \"set_rgb\", \"value\": { \"r\": r, \"g\": g, \"b\": b } }`) and send it using the WebSocket instance. Consider debouncing the handler to prevent flooding the connection.",
            "status": "done",
            "testStrategy": "Open the browser's developer tools to the Network tab. Use the color picker and verify that a WebSocket message with the correct `set_rgb` command and RGB payload is sent upon finalizing a color selection."
          },
          {
            "id": 4,
            "title": "Display Current Color from ESP32 State",
            "description": "Connect the component to the global state management for WebSockets to display the current color as reported by the ESP32.",
            "dependencies": [
              "11.2"
            ],
            "details": "In `ColorPickerControl.tsx`, subscribe to the WebSocket state context that is updated by the `onmessage` handler (as implemented for Task 5). Read the current RGB color from the state (e.g., from a `state.lighting.rgb` object). Use this value to set the `color` prop of the `<SketchPicker />` component and to set the background color of the `<PopoverTrigger>` button, providing visual feedback of the current state.",
            "status": "done",
            "testStrategy": "With the application running, manually send a WebSocket message from the browser console to simulate an ESP32 state update with a new color. Verify that the trigger button's background color and the color picker's selected color update automatically."
          },
          {
            "id": 5,
            "title": "Integrate ColorPickerControl into the Main Dashboard",
            "description": "Place the newly created `ColorPickerControl` component into the main dashboard UI alongside other device controls.",
            "dependencies": [
              "11.3",
              "11.4"
            ],
            "details": "Locate the main dashboard component file (e.g., `src/app/page.tsx` or a `Dashboard.tsx` component). Import the `ColorPickerControl` component and render it within the dashboard layout, likely in a card or section dedicated to lighting controls. Ensure it is visually aligned with existing controls like the pump switches.",
            "status": "done",
            "testStrategy": "Load the main dashboard page. Verify the color picker control is present and fully functional. Test the end-to-end flow: select a color, see the physical LED change, and see the UI control reflect the state broadcasted back from the ESP32."
          }
        ]
      },
      {
        "id": 12,
        "title": "Firmware: Integrate Tuya IoT SDK for Cloud Connectivity",
        "description": "Integrate the Tuya IoT SDK into the PlatformIO project. Implement the necessary boilerplate to connect the ESP32 to the Tuya cloud using credentials provisioned over the local network.",
        "details": "Add the Tuya SDK as a library dependency. Follow the SDK documentation to initialize the Tuya service. Implement the WiFi provisioning process (e.g., SmartConfig or AP mode) to get WiFi and Tuya credentials. Handle connection/disconnection events with the Tuya cloud.",
        "testStrategy": "Flash the firmware. Use the Tuya Smart Life app to attempt to pair a new device. Verify via serial logs that the ESP32 receives credentials, connects to the home WiFi, and successfully registers with the Tuya cloud.",
        "priority": "high",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Tuya SDK and Basic Initialization",
            "description": "Integrate the Tuya IoT SDK into the PlatformIO project by adding it as a library dependency in `platformio.ini`. Add the necessary includes and perform the basic SDK initialization in `src/main.cpp`.",
            "dependencies": [],
            "details": "Modify `platformio.ini` to include the official `tuya/tuya-iot-sdk-for-arduino` library. In `src/main.cpp`, include `<TuyaWifi.h>`. In the `setup()` function, call `tuya_iot_sdk_init()` with the Product ID (PID) obtained from the Tuya IoT Platform. Define a placeholder for the PID at the top of the file. This sets the foundation for all subsequent Tuya-related functionality.",
            "status": "pending",
            "testStrategy": "Compile the firmware successfully. Check the serial monitor output on boot to ensure there are no crashes or errors related to the Tuya SDK initialization. Verify that the SDK initialization function is called."
          },
          {
            "id": 2,
            "title": "Implement Tuya SmartConfig (EZ Mode) Provisioning",
            "description": "Implement the logic to start the Tuya SmartConfig (EZ Mode) provisioning process. This mode should be triggered when the device fails to connect to a previously saved WiFi network.",
            "dependencies": [
              "12.1"
            ],
            "details": "In `src/main.cpp`, modify the existing WiFi connection logic. If connecting with credentials from NVS fails, instead of (or in addition to) starting the custom AP mode from Task 16, call the Tuya SDK function to start SmartConfig provisioning (e.g., `tuya_wifi_start_smart_config()`). The device's status LED (if available) should be set to a fast blink pattern to indicate it's in pairing mode, as per Tuya's standard.",
            "status": "pending",
            "testStrategy": "Clear any saved WiFi credentials from NVS. Power on the device. Verify via serial logs that the device fails to connect to WiFi and then enters SmartConfig mode. The status LED should blink rapidly. The device should be discoverable by the Tuya Smart Life app when using the 'Auto Scan' or 'Add Manually (Wi-Fi)' EZ Mode."
          },
          {
            "id": 3,
            "title": "Implement Callback for Receiving and Storing Credentials",
            "description": "Create and register the callback function that the Tuya SDK will invoke upon successful provisioning to provide the WiFi credentials and Tuya-specific tokens.",
            "dependencies": [
              "12.2"
            ],
            "details": "Implement the `gw_net_status_cb` callback function in `src/main.cpp`. Within this callback, handle the `GW_WIFI_CONN_SUCC` case. When this event occurs, the SDK has successfully received credentials. The device should then stop the provisioning mode, use the provided credentials to connect to the user's WiFi network, and save the SSID and password to NVS using the `Preferences` library for future boots.",
            "status": "pending",
            "testStrategy": "With the device in SmartConfig mode, use the Tuya app to add it. Enter your WiFi credentials in the app. Monitor the serial output to confirm that the callback is triggered, the correct SSID is received, and the device successfully connects to the specified WiFi network. After a reboot, verify the device connects automatically using the newly saved credentials."
          },
          {
            "id": 4,
            "title": "Handle Tuya Cloud Connection State",
            "description": "Implement logic to manage the connection to the Tuya MQTT cloud and handle connection/disconnection events.",
            "dependencies": [
              "12.3"
            ],
            "details": "After a successful WiFi connection, the Tuya SDK will automatically attempt to connect to the Tuya cloud. In the `gw_net_status_cb` callback implemented in the previous subtask, add handlers for cloud connection status events like `GW_MQTT_CONN_SUCC` (connected to cloud) and `GW_MQTT_OFFLINE` (disconnected). Log these events to the serial monitor for debugging. This ensures the device's cloud connectivity status is tracked.",
            "status": "pending",
            "testStrategy": "After the device connects to WiFi, monitor the serial output. Verify that logs indicate a successful connection to the Tuya MQTT cloud. In the Tuya IoT Platform, check that the device's status changes to 'Online'. Physically disconnect the device from the internet (e.g., turn off the router) and verify that a disconnection event is logged."
          },
          {
            "id": 5,
            "title": "Define and Register Data Points (DPs) for Pump Control",
            "description": "Define the Tuya Data Point (DP) for the main pump switch and implement the callback to handle commands from the Tuya cloud.",
            "dependencies": [
              "12.4"
            ],
            "details": "Define a DPID for a boolean switch (e.g., DPID 1 for the pump). Create a `TY_OBJ_DP_S` structure array to declare this DP. In `setup()`, after the SDK is initialized, register these DPs. Implement the `dp_process` callback function. Inside this callback, check for the pump's DPID. When a command is received for this DP, parse its value (true/false) and call the existing `setPumpState` function accordingly. Also, implement logic to report the pump's state back to the cloud using `dev_report_dp_json_async` whenever it's changed locally.",
            "status": "pending",
            "testStrategy": "After the device is online in the Tuya app, a switch control for the pump should appear. Toggle the switch in the app. Verify via serial logs and by observing the physical relay that the pump turns on and off. Manually trigger a state change locally (if possible) and verify the state is updated correctly in the app."
          }
        ]
      },
      {
        "id": 13,
        "title": "Tuya Platform: Define Device and Data Points (DPs)",
        "description": "On the Tuya IoT Developer Platform, create a new product based on a custom template. Define all the necessary Data Points (DPs) for the pool controller.",
        "details": "Define boolean DPs for each of the 4 pumps (e.g., `dp_id: 101, name: Pump 1, type: Boolean`). Define integer/value DPs for temperature and luminosity. Define a string/JSON DP for RGB color control (e.g., `dp_id: 106, name: Light Color, type: String, format: 'hsv'`).",
        "testStrategy": "This is a configuration task. The test is to have a complete and logical device definition on the Tuya platform that can be used for firmware integration. Review the created DPs to ensure they cover all core features.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create New Custom Product on Tuya Platform",
            "description": "Log into the Tuya IoT Developer Platform and initiate the creation of a new product. Select 'Create' > 'Can't find the category?' to build a custom product from scratch. Choose a suitable category, such as 'Electrical', and name the product 'ESP32 Pool Controller'.",
            "dependencies": [],
            "details": "This initial step sets up the product container on the Tuya platform where all Data Points (DPs) will be defined. The product will be based on a custom template, not a pre-existing one.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Define Boolean Data Points for Pumps",
            "description": "In the 'Function Definition' section of the new Tuya product, create four standard functions with a 'Switch' (Boolean) data type. Name them 'Pump 1', 'Pump 2', 'Pump 3', and 'Pump 4'. Assign sequential DP IDs starting from 101.",
            "dependencies": [
              "13.1"
            ],
            "details": "This task covers the primary control functions of the device. Each DP will represent the on/off state of a physical pump relay. The DP IDs should be documented for use in the firmware (Task 14).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Define Value Data Points for Sensors",
            "description": "Create two standard functions with a 'Value' (Integer) data type to report sensor readings. Define one for temperature and another for luminosity. Configure their properties, such as name ('Temperature', 'Luminosity'), unit ('°C', '%'), and valid range (e.g., -20 to 80 for temp, 0 to 1000 for luminosity).",
            "dependencies": [
              "13.2"
            ],
            "details": "Based on the firmware's capabilities (Task 4), these DPs will allow the device to report environmental data to the Tuya cloud and app. The ranges and units should match the data being sent by the ESP32.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Define String Data Point for RGB Light Control",
            "description": "Create a standard function for RGB light control. Select the 'Colour' (String) data type. Name it 'Light Color' and ensure its data format specification is set to HSV, which typically corresponds to a JSON string format like `{\"h\":360,\"s\":100,\"v\":100}`.",
            "dependencies": [
              "13.3"
            ],
            "details": "This specific DP type will automatically render a color wheel picker in the Tuya Smart Life mobile app, providing a user-friendly way to control the pool light's color. The firmware will need to parse this HSV string (Task 14).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Finalize Product Definition and Review Panel UI",
            "description": "Review all defined DPs for correctness. Navigate to the 'Device Panel' section and select a suitable template (e.g., 'All-in-One Panel'). Arrange the DPs for a logical user experience. Complete the product creation workflow to obtain the Product ID (PID) and secret keys needed for firmware integration.",
            "dependencies": [
              "13.4"
            ],
            "details": "This final configuration step ensures the product is ready for development. The PID and keys are essential for the ESP32 to authenticate with the Tuya cloud. A quick check of the default panel ensures all controls are accessible.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 14,
        "title": "Firmware: Map Device State to Tuya Data Points (DPs)",
        "description": "Implement the two-way synchronization between the ESP32's local state and the Tuya cloud DPs. Report local changes to the cloud and handle commands from the cloud.",
        "details": "Implement the DP reporting function to send updates to Tuya whenever a pump state or sensor value changes. Implement the DP command handler function that gets called by the SDK when a command is received from the cloud. In this handler, parse the command and call local functions like `setPumpState` or `setRgbColor`.",
        "testStrategy": "Use the Tuya Smart Life app to control the device. Toggle a pump switch in the app and verify the physical relay on the ESP32 activates. Manually heat the temperature sensor and verify the value updates in the app.",
        "priority": "high",
        "dependencies": [
          12,
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define and Centralize Tuya DP ID Constants",
            "description": "Create a centralized set of constant definitions for all Tuya Data Point (DP) IDs that will be used by the device, such as pumps, sensors, and RGB control. This ensures consistency and avoids magic numbers in the code.",
            "dependencies": [],
            "details": "In a suitable configuration header file (e.g., `src/config.h`), add `#define` macros for each DP ID corresponding to a device function. For example: `DPID_PUMP1_SWITCH`, `DPID_TEMPERATURE_CURRENT`, `DPID_RGB_COLOR_DATA`. These definitions will be included and used by both the command handling and state reporting logic.",
            "status": "pending",
            "testStrategy": "Code review to ensure all required DPs from the Tuya IoT Platform are defined and named logically. Compilation check to ensure the header file is correctly included where needed."
          },
          {
            "id": 2,
            "title": "Implement Tuya Command Handler for Pump Switches",
            "description": "Implement the main DP command processing callback function required by the Tuya SDK. This function will handle incoming commands from the Tuya cloud, starting with the simple boolean switches for the pumps.",
            "dependencies": [
              "14.1"
            ],
            "details": "In `src/main.cpp`, create the function `void dp_process(TY_OBJ_DP_S *dp)` which will be registered as the command callback during Tuya initialization. Inside this function, use a switch statement on `dp->dpid`. Add cases for each pump switch DP ID. In each case, extract the boolean value (`dp->value.dp_bool`) and call the local `setPumpState(pump_id, state)` function to control the physical relay.",
            "status": "pending",
            "testStrategy": "Use the Tuya Smart Life app to toggle the pump switches. Verify via serial monitor logs and by observing the physical relays/LEDs that the `dp_process` function is called and correctly triggers the `setPumpState` function."
          },
          {
            "id": 3,
            "title": "Implement DP Reporting for Pump State Changes",
            "description": "Create a function to report the state of a pump to the Tuya cloud and integrate it into the existing `setPumpState` function. This ensures that any change to a pump's state, regardless of origin (Tuya app, web UI, schedule), is reflected in the app.",
            "dependencies": [
              "14.1"
            ],
            "details": "Create a new helper function, `void report_pump_state(int pump_id, bool state)`. This function will map the local `pump_id` to the correct Tuya `DPID` and use the Tuya SDK function `dev_report_dp_json_async` to send the boolean state. Modify the existing `setPumpState` function to call `report_pump_state` immediately after the pump's state is physically changed.",
            "status": "pending",
            "testStrategy": "Control a pump using a non-Tuya method (e.g., the local web interface or a schedule). Verify that the switch state in the Tuya Smart Life app updates automatically to reflect the change."
          },
          {
            "id": 4,
            "title": "Extend Handler and Reporting for RGB Color Control",
            "description": "Expand the Tuya integration to handle the more complex RGB color data point. This involves parsing the color data string from Tuya commands and formatting local RGB values into the required string format for reporting.",
            "dependencies": [
              "14.1",
              "14.2"
            ],
            "details": "1. In the `dp_process` function, add a case for `DPID_RGB_COLOR_DATA`. Parse the incoming string value (`dp->value.dp_str`), which is typically in a format like `RRGGBBHHSSVV` (Red, Green, Blue, Hue, Saturation, Value). Extract the R, G, and B values and call the local `setRgbColor(r, g, b)` function. 2. Modify `setRgbColor` to call a new reporting function, `report_rgb_color(r, g, b)`, which formats the RGB values into the required Tuya string format and sends the update using `dev_report_dp_json_async`.",
            "status": "pending",
            "testStrategy": "Use the color picker in the Tuya app to set a color. Verify the physical RGB LED changes accordingly. Manually call `setRgbColor` via another method (e.g., WebSocket) and verify the color picker in the Tuya app updates to the new color."
          },
          {
            "id": 5,
            "title": "Implement Periodic Reporting for Sensor Values",
            "description": "Add logic to periodically read sensor values (e.g., temperature) and report them to the Tuya cloud. This ensures the data displayed in the app is kept reasonably up-to-date.",
            "dependencies": [
              "14.1"
            ],
            "details": "In the main `loop()` function, implement a non-blocking timer using `millis()`. Set an interval (e.g., every 60 seconds). When the timer elapses, read the latest value from the temperature sensor. Compare it with the last reported value. If it has changed, use `dev_report_dp_json_async` to report the new value to the corresponding DP ID (`DPID_TEMPERATURE_CURRENT`). Update the 'last reported value' variable.",
            "status": "pending",
            "testStrategy": "Let the device run and monitor the serial output for logs indicating sensor data is being reported. Manually change the sensor's reading (e.g., by warming a temperature sensor) and verify that the new value appears in the Tuya app within the specified reporting interval."
          }
        ]
      },
      {
        "id": 15,
        "title": "Firmware: Implement STA/AP WiFi Mode",
        "description": "Implement logic for the ESP32 to first attempt connecting to a known WiFi network (STA mode). If the connection fails after a set number of attempts, it should fall back to creating its own Access Point (AP mode) for emergency configuration. This improves usability by making the device accessible on the local network by default.",
        "details": "",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Firmware: Create Web-based WiFi Configurator for AP Mode",
        "description": "Develop a web page served in AP mode that allows users to scan for WiFi networks, enter credentials, and save them to the ESP32's NVS. The device will then restart and attempt to connect to the new network.",
        "details": "When the ESP32 fails to connect to a known network and enters AP mode (as implemented in Task 15), it must serve a dedicated configuration portal. \n1. **Captive Portal:** In the AP mode setup block in `main.cpp`, implement a DNS server that redirects all domain name requests to the ESP32's IP (192.168.4.1). This ensures that when a user connects to the 'Quinta-dos-Britos-Config' WiFi, their browser automatically opens the configuration page.\n2. **Web Server Routes (AP Mode):**\n   - `server.on(\"/\", HTTP_GET, ...)`: Serve a new HTML file, e.g., `/ap_config.html`, from the SPIFFS/LittleFS filesystem.\n   - `server.on(\"/api/scanwifi\", HTTP_GET, ...)`: Create an endpoint that triggers `WiFi.scanNetworks()`, formats the results (SSID and RSSI) into a JSON array using `ArduinoJson`, and sends it to the client.\n   - `server.on(\"/api/savewifi\", HTTP_POST, ...)`: Create an endpoint to handle the form submission. Use the `AsyncWebBodyParser` to parse the `ssid` and `password` from the request. Save these credentials to NVS using the `Preferences` library with keys like `\"wifi_ssid\"` and `\"wifi_pass\"`. After saving, send a success response and call `ESP.restart()`.\n3. **Frontend (`ap_config.html`):** Create a simple, self-contained HTML page. It should include JavaScript to:\n   - On page load, or via a 'Scan' button, make a `fetch` request to `/api/scanwifi`.\n   - Populate a `<select>` dropdown with the returned network SSIDs.\n   - On form submission, send the selected SSID and password input to `/api/savewifi` using a POST request.\n   - Display a message to the user indicating that the device is saving and restarting.",
        "testStrategy": "1. Ensure no WiFi credentials are stored in NVS to force the device into AP mode on boot. You can write a temporary sketch with `Preferences.clear()` to do this.\n2. Power on the ESP32. Connect a phone or laptop to the 'Quinta-dos-Britos-Config' WiFi network.\n3. The captive portal should automatically open the configuration page in the browser. If not, manually navigate to `192.168.4.1`.\n4. Verify the page loads correctly. Click the 'Scan' button and check that the dropdown populates with local WiFi networks.\n5. Select your home network, enter the correct password, and click 'Save'.\n6. The browser should show a success/restarting message. Monitor the Serial output to confirm the credentials are received, saved, and that `ESP.restart()` is called.\n7. After restart, verify via Serial Monitor that the ESP32 now successfully connects to the provided home WiFi in STA mode and gets an IP address.",
        "status": "done",
        "dependencies": [
          15
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Captive Portal DNS Server in AP Mode",
            "description": "In `main.cpp`, within the AP mode setup block, instantiate and configure a `DNSServer`. The server should be configured to respond to all DNS queries with the ESP32's AP IP address, forcing connected devices to open the configuration portal.",
            "dependencies": [],
            "details": "Include the `DNSServer.h` library. In the `else` block for AP mode in `main.cpp`, after `WiFi.softAP()` is called, create a `DNSServer` object. Start the DNS server on port 53, mapping all domains ('*') to the AP's IP address. In the main `loop()`, add a conditional check to only call `dnsServer.processNextRequest()` when the device is in AP mode.",
            "status": "done",
            "testStrategy": "Connect a device to the 'Quinta-dos-Britos-Config' WiFi. Open a browser and attempt to navigate to any website (e.g., google.com). The browser should be redirected to the ESP32's web server page (even if it's just a 'Not Found' page for now)."
          },
          {
            "id": 2,
            "title": "Setup AsyncWebServer and Serve Configuration Page",
            "description": "Add the `ESPAsyncWebServer` library, create a basic `ap_config.html` file, and configure the web server to serve this file from the LittleFS filesystem when a client connects in AP mode.",
            "dependencies": [],
            "details": "Add `esphome/ESPAsyncWebServer` and its dependency `esphome/AsyncTCP` to `platformio.ini`. Create a `data` directory in the project root and place a new file `ap_config.html` inside it. This HTML should contain a basic form with a `<select>` for SSIDs, a password `<input>`, and a submit button. In `main.cpp`, include `ESPAsyncWebServer.h` and `LittleFS.h`. Initialize LittleFS in `setup()`. In the AP mode block, instantiate `AsyncWebServer` on port 80. Create a route `server.on(\"/\", HTTP_GET, ...)` to serve `data/ap_config.html`. Also, add a `server.onNotFound(...)` handler that serves the same page to assist the captive portal.",
            "status": "done",
            "testStrategy": "After flashing with the filesystem image, connect to the AP. The captive portal (or manually navigating to 192.168.4.1) should display the contents of `ap_config.html`."
          },
          {
            "id": 3,
            "title": "Create `/api/scanwifi` Endpoint to List Networks",
            "description": "Implement a new `AsyncWebServer` GET route, `/api/scanwifi`, that performs a WiFi scan. The results (SSID and RSSI) should be formatted into a JSON array and sent as the response.",
            "dependencies": [
              "16.2"
            ],
            "details": "In `main.cpp`, add a new server route `server.on(\"/api/scanwifi\", HTTP_GET, ...)`. Inside the handler lambda, call `WiFi.scanNetworks()` to get the number of networks. Iterate through the results, and for each network, use the `ArduinoJson` library to construct a JSON array of objects. Each object should contain the `ssid` and `rssi`. Serialize the JSON document and send it as the response with a content type of `application/json`.",
            "status": "done",
            "testStrategy": "While connected to the AP, navigate your browser to `http://192.168.4.1/api/scanwifi`. The browser should display a JSON array of nearby WiFi networks."
          },
          {
            "id": 4,
            "title": "Create `/api/savewifi` Endpoint to Store Credentials",
            "description": "Implement a POST route, `/api/savewifi`, to receive and process WiFi credentials. The endpoint will parse the submitted SSID and password, save them to NVS using the `Preferences` library, and trigger a device restart.",
            "dependencies": [
              "16.2"
            ],
            "details": "In `main.cpp`, add a new server route `server.on(\"/api/savewifi\", HTTP_POST, ...)`. Inside the handler, check for the presence of `ssid` and `password` parameters in the request. Use the existing `Preferences` instance (already used for reading credentials) to open the `wifi-creds` namespace and save the received values to the keys `\"wifi_ssid\"` and `\"wifi_pass\"`. After calling `preferences.end()`, send a `200 OK` response with a simple text message and then call `ESP.restart()` to apply the new settings.",
            "status": "done",
            "testStrategy": "Use a tool like `curl` or Postman to send a POST request to `http://192.168.4.1/api/savewifi` with `ssid` and `password` data. Monitor the serial output to confirm that the device receives the data, saves it, and restarts."
          },
          {
            "id": 5,
            "title": "Implement Frontend JavaScript for Dynamic Interaction",
            "description": "Enhance `ap_config.html` with JavaScript to fetch available WiFi networks from the API, populate the dropdown menu, and handle the form submission asynchronously using the `fetch` API.",
            "dependencies": [
              "16.3",
              "16.4"
            ],
            "details": "In `data/ap_config.html`, add a `<script>` section. Write a function that executes on page load to `fetch('/api/scanwifi')`. Parse the JSON response and dynamically create `<option>` elements for the SSID `<select>` dropdown. Add an event listener to the form's `submit` event. In the listener, call `event.preventDefault()`, retrieve the selected SSID and the password from the input field, and use `fetch('/api/savewifi', ...)` with a `POST` method and a URL-encoded body to send the credentials. Upon a successful response, update the page to show a message like 'Success! Device is restarting...'",
            "status": "done",
            "testStrategy": "Open the configuration page in a browser. Verify the WiFi network dropdown is populated. Select a network, enter the password, and click submit. The page should display a success message, and the ESP32's onboard LED should indicate a restart. The device should then connect to the specified network."
          }
        ]
      },
      {
        "id": 17,
        "title": "Firmware: Implement Comprehensive Safety System",
        "description": "Implement a multi-layered safety system including an emergency stop, pump timeouts, hardware watchdog, and state validation to ensure safe and reliable operation of the pool controller.",
        "details": "This task is critical for device safety. Implementation should be done in `src/main.cpp` and related web interface files in the `data/` directory.\n\n1.  **Emergency Stop (E-Stop):**\n    *   Define a global volatile boolean `emergencyStopActive = false;`.\n    *   Configure a dedicated GPIO pin as `INPUT_PULLUP` for a physical E-Stop button.\n    *   Create an Interrupt Service Routine (ISR) attached to this pin that sets `emergencyStopActive = true;` and immediately calls a function to disable all pump relays.\n    *   Modify the WebSocket handler (from Task 1) to accept a new command `{\"action\": \"emergency_stop\"}`. This handler will also set the `emergencyStopActive` flag and disable all pumps.\n    *   Modify the `setPumpState` function to prevent turning any pump ON if `emergencyStopActive` is true. The flag should only be resettable via a device reboot.\n\n2.  **Automatic Pump Timeouts:**\n    *   Define a constant `MAX_PUMP_DURATION_MS` (e.g., 4 * 3600 * 1000 for 4 hours).\n    *   Create an array `unsigned long pumpActivationTime[4] = {0};`.\n    *   In `setPumpState`, when a pump is turned ON, record the timestamp: `pumpActivationTime[pumpId] = millis();`.\n    *   In the main `loop()`, iterate through all pumps. If a pump is active and `(millis() - pumpActivationTime[i]) > MAX_PUMP_DURATION_MS`, call `setPumpState(i, false)` and log a timeout event.\n\n3.  **Hardware Watchdog Timer (WDT):**\n    *   In `setup()`, initialize the ESP32's Task Watchdog Timer (TWDT). Include `<esp_task_wdt.h>`. Use `esp_task_wdt_init(WDT_TIMEOUT_S, true);` and `esp_task_wdt_add(NULL);` to subscribe the main loop task. Set `WDT_TIMEOUT_S` to a reasonable value (e.g., 10 seconds).\n    *   In the main `loop()`, ensure `esp_task_wdt_reset();` is called periodically to prevent a reset.\n\n4.  **Audit Logging:**\n    *   Create a helper function `logAuditEvent(const String& event)`. Initially, this will print formatted messages to `Serial` (e.g., `[AUDIT] [timestamp] - event`).\n    *   Log critical events: E-Stop activation (physical/web), pump auto-shutdown due to timeout, pump activation denied due to safety rules, and system boot after a WDT reset.\n\n5.  **Fail-Safe Default State:**\n    *   In `setup()`, immediately after configuring pump GPIOs as outputs, iterate through all pump pins and use `digitalWrite()` to set them to their OFF state. This ensures all pumps are disabled on boot or after a reset.\n\n6.  **System Health Monitoring:**\n    *   Create a function that gathers system health metrics (e.g., `ESP.getFreeHeap()`, `millis()`).\n    *   Expose these metrics via a new REST endpoint (e.g., `/api/health`) or periodically push them over WebSocket.\n\n7.  **Web Interface Integration:**\n    *   Modify `data/index.html` to add a large, clearly visible 'EMERGENCY STOP' button. This button should be styled distinctively (e.g., red background).\n    *   In the corresponding JavaScript file, implement the `onclick` event for this button to send the `{\"action\": \"emergency_stop\"}` WebSocket message.\n    *   Add a status panel to the UI that listens for WebSocket messages from the server to display security alerts like 'EMERGENCY STOP ACTIVATED' or 'Pump X timed out'.",
        "testStrategy": "1.  **Fail-Safe Test:** Power on/reset the ESP32. Verify with a multimeter or LEDs that all pump relay outputs are in the OFF state by default.\n2.  **E-Stop (Physical):** Turn on one or more pumps via the web UI. Ground the configured E-Stop GPIO pin. Verify all pumps turn off instantly and cannot be turned back on via the UI. Check serial logs for the audit message.\n3.  **E-Stop (Web):** Turn on pumps via the UI. Click the 'EMERGENCY STOP' button on the web page. Verify all pumps turn off, an alert appears in the UI, and pumps cannot be reactivated.\n4.  **Timeout Test:** In the firmware, temporarily reduce `MAX_PUMP_DURATION_MS` to 15000 (15 seconds). Turn on a pump and wait. Verify it automatically turns off after 15 seconds and an audit log is printed to the serial monitor.\n5.  **Watchdog Test:** In the main `loop()`, add a `while(true);` delay to simulate a software hang. Power on the device and verify that it automatically reboots after the configured WDT timeout period (e.g., 10 seconds).\n6.  **Logging Test:** Perform all the above tests while monitoring the `Serial` output. Confirm that formatted audit logs are generated for each specific safety event.\n7.  **Health Check Test:** While the device is running, navigate to the `/api/health` endpoint in a browser or use a tool like Postman to verify it returns a JSON object with current health data (uptime, free memory).",
        "status": "pending",
        "dependencies": [
          1,
          14,
          16
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Core Emergency Stop Logic (Firmware)",
            "description": "Implement the core firmware logic for the emergency stop feature, including the physical button interrupt, the WebSocket command handler, and enforcement in the pump control function.",
            "dependencies": [],
            "details": "In `src/main.cpp`, define a global volatile boolean `emergencyStopActive`. Configure a GPIO pin for a physical button with an ISR that sets this flag to true and calls a new function `disableAllPumps()`. Modify the existing WebSocket handler to process `{\"action\": \"emergency_stop\"}` which also sets the flag and calls `disableAllPumps()`. Crucially, update the `setPumpState` function to check `emergencyStopActive` and prevent any pump from being turned on if it's true. The flag should only be resettable by a device reboot.",
            "status": "pending",
            "testStrategy": "1. After flashing, turn on a pump via the web UI. Ground the configured E-Stop GPIO pin. Verify all pumps turn off instantly. 2. Attempt to turn a pump back on via the UI; verify it fails. 3. Reboot the device. Send the `{\"action\": \"emergency_stop\"}` WebSocket message. Verify all pumps turn off and cannot be re-activated."
          },
          {
            "id": 2,
            "title": "Implement Fail-Safe Boot State and Automatic Pump Timeouts",
            "description": "Ensure all pumps default to OFF on boot and implement a timeout mechanism to prevent any single pump from running indefinitely.",
            "dependencies": [],
            "details": "In `src/main.cpp`, at the beginning of the `setup()` function, immediately after configuring the pump GPIOs as outputs, iterate through all pump pins and use `digitalWrite()` to set them to their OFF state. For timeouts, define `MAX_PUMP_DURATION_MS`. Create a `pumpActivationTime` array. In `setPumpState`, record `millis()` when a pump is turned ON. In the main `loop()`, check if any active pump has exceeded the max duration. If so, call `setPumpState` to turn it off.",
            "status": "pending",
            "testStrategy": "1. Power on/reset the device. Verify with a multimeter that all pump relay outputs are OFF. 2. Turn on a pump. Let it run past the configured `MAX_PUMP_DURATION_MS`. Verify the pump automatically turns off and a log message is printed."
          },
          {
            "id": 3,
            "title": "Integrate Hardware Watchdog and Centralized Audit Logging",
            "description": "Set up the ESP32's hardware watchdog to recover from freezes and create a logging function to record all critical safety-related events.",
            "dependencies": [
              "17.1",
              "17.2"
            ],
            "details": "In `src/main.cpp`, create a new function `logAuditEvent(const String& event)` that prints a formatted message to the Serial console. In `setup()`, include `<esp_task_wdt.h>` and initialize the Task Watchdog Timer (TWDT) for the main loop task. Call `esp_task_wdt_reset()` at a safe point within the main `loop()`. Add calls to `logAuditEvent` for: E-Stop activation (from both physical and web triggers in Subtask 1), pump timeouts (from Subtask 2), and to detect a boot caused by a WDT reset.",
            "status": "pending",
            "testStrategy": "1. Comment out `esp_task_wdt_reset()` in the loop. Verify the device reboots after the timeout period. Check serial logs for the WDT reset message on boot. 2. Trigger an E-Stop and a pump timeout. Verify corresponding messages are printed to the serial monitor via `logAuditEvent`."
          },
          {
            "id": 4,
            "title": "Add Emergency Stop Button to Web Interface",
            "description": "Modify the web interface to include a prominent 'EMERGENCY STOP' button that triggers the corresponding firmware action.",
            "dependencies": [
              "17.1"
            ],
            "details": "In `data/index.html`, add a new button element with the ID `estop-button` and text 'EMERGENCY STOP'. Style it with a red background and white text to be highly visible. In the corresponding JavaScript file (e.g., `data/app.js`), add an `onclick` event listener to this button. The listener should send the WebSocket message `JSON.stringify({action: 'emergency_stop'})` to the ESP32.",
            "status": "pending",
            "testStrategy": "1. Load the web interface in a browser. 2. Turn on a pump. 3. Click the new 'EMERGENCY STOP' button. 4. Verify the pump turns off immediately and a confirmation/status update appears on the UI (as implemented in Subtask 5)."
          },
          {
            "id": 5,
            "title": "Implement UI Status Display for Safety Alerts",
            "description": "Enhance the web interface to display real-time status alerts for safety events like E-Stop activation and pump timeouts.",
            "dependencies": [
              "17.1",
              "17.2",
              "17.4"
            ],
            "details": "In `src/main.cpp`, modify the firmware to broadcast a WebSocket message whenever a safety event occurs (e.g., `{\"status\": \"estop_active\"}` or `{\"status\": \"pump_timeout\", \"pump\": 2}`). In `data/index.html`, add a dedicated status area (e.g., a `<div>` with ID `safety-status-panel`). In the JavaScript file, enhance the WebSocket `onmessage` handler to listen for these new status messages. When a message is received, update the `safety-status-panel` to display a clear, user-friendly alert (e.g., 'EMERGENCY STOP ACTIVATED' in red text). The E-Stop alert should be persistent until the device is rebooted.",
            "status": "pending",
            "testStrategy": "1. With the web UI open, trigger a physical E-Stop. Verify the 'EMERGENCY STOP ACTIVATED' message appears on the page and remains. 2. Reboot the device, open the UI, and let a pump time out. Verify a 'Pump X Timed Out' message appears."
          }
        ]
      },
      {
        "id": 18,
        "title": "Implement Core Firmware Safety Mechanisms (Watchdog, Timeouts, Failsafe)",
        "description": "Enhance the ESP32 firmware to include critical safety features as defined in the PRD. This includes a hardware watchdog timer to prevent system freezes, configurable operational timeouts for each pump to prevent them from running indefinitely, and a failsafe mechanism to shut down all pumps if communication with the client is lost.",
        "details": "1. **Hardware Watchdog (WDT):** Implement the ESP32's built-in Task Watchdog Timer (`esp_task_wdt`). Initialize it in `setup()` with a timeout of 30 seconds and reset it in the main `loop()` to prevent system hangs. 2. **Pump Timeouts:** For each pump, track its continuous run time using `millis()`. Create a configurable `maxRunTime` variable (defaulting to 4 hours per PRD). If a pump exceeds this time, automatically shut it off and log the event. 3. **Communication Failsafe:** Implement a WebSocket heartbeat. The frontend will send a 'ping' message every 5 seconds. If the ESP32 doesn't receive a message for 30 seconds, it must enter a failsafe state, turning off all relays.",
        "testStrategy": "1. **WDT Test:** Introduce a temporary `while(true);` loop in the code to confirm the ESP32 reboots automatically. 2. **Timeout Test:** Set a short `maxRunTime` (e.g., 15 seconds) for one pump, activate it, and verify it deactivates automatically after the specified duration. 3. **Failsafe Test:** With pumps running, close the frontend browser tab (disconnecting the WebSocket client) and verify all pumps shut down after the 30-second failsafe period.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Hardware Watchdog Timer (WDT)",
            "description": "Integrate the ESP32's Task Watchdog Timer (WDT) to prevent firmware freezes. This involves initializing the WDT in the setup function and resetting it in the main loop.",
            "dependencies": [],
            "details": "In `src/main/main.ino`, include the `esp_task_wdt.h` library. In the `setup()` function, initialize the WDT with a 30-second timeout using `esp_task_wdt_init()` and `esp_task_wdt_add()`. In the main `loop()` function, add a call to `esp_task_wdt_reset()` to feed the watchdog on every iteration.",
            "status": "pending",
            "testStrategy": "Temporarily add a `while(true);` delay inside the `loop()` function. Upload the firmware and verify that the ESP32 reboots automatically after approximately 30 seconds."
          },
          {
            "id": 2,
            "title": "Define State Variables for Pump Timeouts",
            "description": "Add the necessary global variables to the firmware to track the continuous run time for each pump.",
            "dependencies": [],
            "details": "In `src/main/main.ino`, near the existing pump state arrays, define a configurable `maxRunTime` constant (e.g., `const unsigned long maxRunTime = 4 * 60 * 60 * 1000;` for 4 hours). Also, define an array `unsigned long pumpStartTimes[NUM_PUMPS] = {0};` to store the `millis()` timestamp when each pump was turned on.",
            "status": "pending",
            "testStrategy": "Compile the code to ensure the new variables are defined correctly without syntax errors. No functional test is needed for this step."
          },
          {
            "id": 3,
            "title": "Implement Pump Timeout Logic",
            "description": "Modify the pump control logic to track run times and automatically shut off pumps that exceed the maximum configured duration.",
            "dependencies": [
              "18.2"
            ],
            "details": "In `src/main/main.ino`, modify the `setPumpState` function. When a pump is turned ON (`state == true`), record the current time using `pumpStartTimes[pumpId] = millis();`. When turned OFF, reset it: `pumpStartTimes[pumpId] = 0;`. In the main `loop()`, add a new function or block that iterates through all pumps. If a pump is on (`pumpStates[pumpId] == true` and `pumpStartTimes[pumpId] != 0`), check if `millis() - pumpStartTimes[pumpId] > maxRunTime`. If true, call `setPumpState(pumpId, false)` and log the event to the Serial monitor.",
            "status": "pending",
            "testStrategy": "Set `maxRunTime` to a short duration like 15000 (15 seconds). Use the web UI to turn on a pump. Verify that the pump automatically turns off after 15 seconds and a message is printed to the Serial monitor."
          },
          {
            "id": 4,
            "title": "Implement WebSocket Communication Failsafe Timer",
            "description": "Establish a timer that tracks the time since the last message was received from the client to detect communication loss.",
            "dependencies": [],
            "details": "In `src/main/main.ino`, define a global variable `unsigned long lastMessageTime = 0;` and a constant `const unsigned long commsTimeout = 30000;`. Inside the `webSocketEvent` function, at the very beginning, update the timer on any incoming event: `lastMessageTime = millis();`. This will reset the failsafe countdown every time a message (including pings) is received.",
            "status": "pending",
            "testStrategy": "Add a `Serial.println(lastMessageTime)` in the main loop. Connect with the UI and observe the serial monitor to confirm the value updates whenever a WebSocket message is sent or received."
          },
          {
            "id": 5,
            "title": "Implement Failsafe Action to Deactivate Pumps",
            "description": "Create the logic in the main loop to check for a communication timeout and trigger a failsafe state by shutting down all pumps.",
            "dependencies": [
              "18.4"
            ],
            "details": "In the main `loop()` of `src/main/main.ino`, add a check: `if (millis() - lastMessageTime > commsTimeout && lastMessageTime != 0)`. Inside this block, call `setPumpState` for all pumps to turn them off (e.g., in a `for` loop). To prevent this from running repeatedly, you can set `lastMessageTime = 0;` after the pumps are shut down, effectively disabling the check until a new connection is established.",
            "status": "pending",
            "testStrategy": "Turn on one or more pumps using the UI. Disconnect the client (close the browser tab or disconnect Wi-Fi). Wait for 30 seconds and verify that all physical relays (or test LEDs) turn off automatically."
          }
        ]
      },
      {
        "id": 19,
        "title": "Integrate and Expose Sensor Data via WebSocket (DS18B20 & LDR)",
        "description": "Implement the firmware code to read data from the DS18B20 temperature sensor and the LDR luminosity sensor. The collected data should be packaged into a structured JSON object and broadcast periodically over the WebSocket connection to the frontend.",
        "details": "1. **Hardware Setup:** Connect the DS18B20 (with a 4.7kΩ pull-up resistor) and the LDR (in a voltage divider with a 10kΩ resistor) to the appropriate ESP32 GPIO pins. 2. **Firmware - DS18B20:** Use the `OneWire` and `DallasTemperature` libraries. Initialize the sensor in `setup()` and read the temperature in the main loop. 3. **Firmware - LDR:** Read the analog value from the LDR's GPIO pin using `analogRead()` and map it to a 0-100% scale. 4. **WebSocket Broadcasting:** Every 2 seconds, create and broadcast a single JSON status object to all clients, e.g., `{\"type\": \"status\", \"temperature\": 25.5, \"luminosity\": 75, \"pumps\": [true, false, false, true]}`. This will be the primary data source for the frontend.",
        "testStrategy": "Use the Arduino Serial Monitor to print raw and processed sensor values to verify they are being read correctly. Heat the temperature sensor and cover the LDR to confirm values change as expected. Use a browser's developer tools to inspect the WebSocket traffic and ensure the JSON status object is being received correctly and periodically.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor Hardware Pin Definitions into a Central `config.h` Header",
            "description": "Create a new `src/config.h` file to centralize all hardware pin configurations. Move the `#define` statements for `ONE_WIRE_BUS` and `LDR_PIN`, and the `pumpPins` array declaration and `numPumps` constant from `src/main.cpp` into this new header. Ensure `main.cpp` includes `config.h` to access these definitions.",
            "dependencies": [],
            "details": "This task improves maintainability by separating configuration from application logic. The new `config.h` should contain the pin definitions for the DS18B20, LDR, and water pumps.",
            "status": "pending",
            "testStrategy": "Compile the firmware to ensure `main.cpp` can still access the pin definitions from the new `config.h` file without errors. Verify that the device still operates as before."
          },
          {
            "id": 2,
            "title": "Add DS18B20 Sensor Presence Verification in `setup()`",
            "description": "Enhance the `setup()` function in `main.cpp` to verify the presence of the DS18B20 sensor on startup. After `sensors.begin()`, use `sensors.getDeviceCount()` to check if any sensors are detected on the OneWire bus. If the count is zero, print a persistent error message to the Serial monitor (e.g., \"DS18B20 sensor not found!\").",
            "dependencies": [],
            "details": "This adds robustness to the system by providing clear feedback during startup if the temperature sensor is disconnected or faulty, preventing the system from attempting to read from a non-existent sensor.",
            "status": "pending",
            "testStrategy": "Flash and run the firmware with the DS18B20 sensor disconnected. Check the Serial Monitor for the specific error message. Reconnect the sensor and restart the ESP32 to ensure the error message does not appear."
          },
          {
            "id": 3,
            "title": "Implement Calibrated LDR Luminosity Mapping",
            "description": "In the `config.h` file created in subtask 1, define `LDR_MIN_ANALOG` and `LDR_MAX_ANALOG` constants for calibration (e.g., initial values of 400 and 3800). In the `readSensors` function, update the luminosity calculation to use these constants. First, use `constrain()` to clamp the raw `analogRead` value within this range, then use `map()` to convert the calibrated value to a 0-100% scale.",
            "dependencies": [
              "19.1"
            ],
            "details": "The current linear mapping from 0-4095 is inaccurate. This task implements a more realistic mapping based on observed minimum (dark) and maximum (bright) analog values, improving the quality of the luminosity data. The mapping should also be inverted (`map(value, LDR_MIN, LDR_MAX, 100, 0)`) if the voltage divider is set up such that lower resistance (more light) results in a lower analog reading.",
            "status": "pending",
            "testStrategy": "Print the raw and mapped LDR values to the Serial Monitor. Cover the LDR completely and note the raw value to set `LDR_MAX_ANALOG`. Shine a bright light on it and note the value for `LDR_MIN_ANALOG`. Update the constants and verify the mapped output is a sensible 0-100%."
          },
          {
            "id": 4,
            "title": "Refactor Global State into a `DeviceState` Struct",
            "description": "Create a new `state.h` header file and define a `struct DeviceState` that contains `float currentTemperature`, `int currentLuminosity`, and `bool pumpStates[numPumps]`. In `main.cpp`, replace the separate global state variables with a single global instance of this `DeviceState` struct. Update the `readSensors` function and the pump control logic in `webSocketEvent` to read from and write to the members of this struct.",
            "dependencies": [
              "19.1"
            ],
            "details": "This refactoring centralizes the device's state into a single, structured object, making the code cleaner and easier to manage. It creates a single source of truth that directly mirrors the structure of the JSON to be broadcast.",
            "status": "pending",
            "testStrategy": "After refactoring, compile and flash the firmware. Use the web UI and Serial Monitor to verify that sensor values are still being read correctly and that pump states can still be toggled, confirming that all parts of the code are correctly accessing the new state struct."
          },
          {
            "id": 5,
            "title": "Update `broadcastStatus` to Use the Central `DeviceState` Struct",
            "description": "Modify the `broadcastStatus` function to read all its data directly from the global `DeviceState` struct instance created in the previous subtask. The function should access `state.currentTemperature`, `state.currentLuminosity`, and iterate over `state.pumpStates` to build the JSON payload. Ensure the main `loop` continues to call `readSensors()` before `broadcastStatus()` to guarantee data freshness.",
            "dependencies": [
              "19.4"
            ],
            "details": "This finalizes the state management refactoring. The `broadcastStatus` function will now be a pure consumer of the centralized state struct, making the data flow explicit: `readSensors` populates the state, and `broadcastStatus` serializes it.",
            "status": "pending",
            "testStrategy": "Connect to the WebSocket with a browser's developer tools. Verify that the broadcasted JSON object correctly reflects the sensor values and pump states contained within the `DeviceState` struct. Change sensor conditions and toggle pumps to see the JSON updates in real-time."
          }
        ]
      },
      {
        "id": 20,
        "title": "Build Real-Time Frontend Dashboard with Shadcn/UI",
        "description": "Overhaul the basic frontend page to create a responsive, real-time dashboard using Shadcn/UI components. The dashboard must display the current status of all pumps and live data from the temperature and luminosity sensors by processing the new JSON status object from the WebSocket.",
        "details": "1. **Layout:** Use Shadcn `Card` components to create a dedicated section for each of the 4 pumps and a separate card for sensor data. 2. **Pump Controls:** Inside each pump `Card`, display its name, a `Badge` for its status (On/Off), and a `Switch` component to toggle its state. The `Switch` will send a command like `{\"command\": \"toggle\", \"pump\": 1}`. 3. **Sensor Display:** In the sensor `Card`, use `lucide-react` icons (e.g., `thermometer`, `sun`) next to the real-time temperature and luminosity values. 4. **State Management:** Use React hooks (`useState`, `useEffect`) to parse the incoming WebSocket status message and update the UI state, ensuring all components re-render with new data.",
        "testStrategy": "Open the dashboard and verify that the pump status `Badge` and `Switch` components update correctly when a pump is toggled. Confirm that the temperature and luminosity values update in real-time on the dashboard. Test the UI on different screen sizes using browser developer tools to ensure the layout is responsive.",
        "priority": "medium",
        "dependencies": [
          19
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor State Management for JSON Status Object",
            "description": "Update the main page's state management in `app/page.tsx` to handle the new comprehensive JSON status object received from the WebSocket. This will serve as the single source of truth for the dashboard's UI.",
            "dependencies": [],
            "details": "In `app/page.tsx`, introduce a `useState` hook to hold the entire device state, initialized with a default structure like `{ pumps: [false, false, false, false], sensors: { temperature: 0, luminosity: 0 } }`. Modify the existing `useEffect` hook that manages the WebSocket connection to parse incoming JSON messages and update this new state variable using `setDeviceState`.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Reusable `PumpCard` Component",
            "description": "Develop a new, reusable React component named `PumpCard.tsx` using Shadcn/UI to display the status and control a single pump. This component will be used for each of the four pumps.",
            "dependencies": [],
            "details": "Create the file `components/PumpCard.tsx`. The component will accept props like `id`, `name`, `status`, and `onToggle`. It will render a Shadcn `Card` containing the `name`, a `Badge` component that displays 'On' or 'Off' with appropriate colors based on the `status` prop, and a `Switch` component. The `Switch`'s `checked` prop will be bound to the `status`, and its `onCheckedChange` handler will call the `onToggle` function with the pump `id`.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create and Integrate `SensorCard` Component",
            "description": "Develop and integrate a `SensorCard.tsx` component on the main dashboard to display live data from the temperature and luminosity sensors.",
            "dependencies": [
              "20.1"
            ],
            "details": "Create the file `components/SensorCard.tsx`. This component will accept a `sensors` object prop (e.g., `{ temperature: 25.5, luminosity: 80 }`). Inside a Shadcn `Card`, display the temperature and luminosity values. Use `lucide-react` icons like `Thermometer` and `Sun` next to their respective values. Import and render this component in `app/page.tsx`, passing the `deviceState.sensors` from the main state.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Integrate `PumpCard` Components into Dashboard",
            "description": "Dynamically render the four `PumpCard` components on the main dashboard page (`app/page.tsx`) by mapping over the state data.",
            "dependencies": [
              "20.1",
              "20.2"
            ],
            "details": "In `app/page.tsx`, import the `PumpCard` component. Within the main return statement, map over the `deviceState.pumps` array. For each pump status in the array, render a `PumpCard` component. Pass the required props: `id` (the array index), `name` (e.g., `Pump ${index + 1}`), `status` (the boolean value from the array), and a handler function that sends the `{\"command\": \"toggle\", \"pump\": index}` message via the WebSocket.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Responsive Dashboard Layout",
            "description": "Arrange the pump and sensor cards into a clean, responsive grid layout using Tailwind CSS to ensure the dashboard is usable across various screen sizes.",
            "dependencies": [
              "20.3",
              "20.4"
            ],
            "details": "In `app/page.tsx`, wrap all the rendered `PumpCard` and `SensorCard` components in a container `div`. Apply Tailwind CSS classes to this container to create a responsive grid (e.g., `grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 p-4`). This will ensure the cards stack on mobile and form a multi-column layout on larger screens.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 21,
        "title": "Implement Emergency Stop and SPIFFS Audit Logging",
        "description": "Implement a system-wide emergency stop (E-Stop) function in the firmware, triggerable from the UI. Additionally, create a logging system that records all critical actions (pump state changes, E-Stop) to the ESP32's SPIFFS filesystem for auditing.",
        "details": "1. **Firmware E-Stop:** Create a function `emergencyStop()` that immediately deactivates all relay GPIOs. Expose this via a WebSocket command handler for `{\"command\": \"estop\"}`. 2. **Frontend E-Stop:** Add a prominent red Shadcn `Button` to the dashboard labeled 'Emergency Stop' that sends the `estop` command. 3. **SPIFFS Logging:** Initialize the SPIFFS filesystem in `setup()`. Create a function `logAuditEvent(const char* event)` that appends a timestamped log entry (e.g., `[1677619200] PUMP_1_ON`) to `/audit.log`. 4. **Log Triggers:** Call `logAuditEvent()` for every pump state change, E-Stop activation, and safety timeout event.",
        "testStrategy": "Click the 'Emergency Stop' button on the UI and verify all pumps turn off instantly. Perform several actions (toggle pumps, trigger E-Stop). Implement a temporary HTTP endpoint or serial command to read and print the contents of `/audit.log` to verify all critical events were recorded correctly.",
        "priority": "high",
        "dependencies": [
          18,
          20
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Firmware: Initialize SPIFFS and Create `logAuditEvent` Function",
            "description": "In the main `.ino` file, include `FS.h` and `SPIFFS.h`. In the `setup()` function, add code to initialize the SPIFFS filesystem (`SPIFFS.begin(true)`). Create a new helper function `void logAuditEvent(const char* event)` that appends a timestamped log entry to the `/audit.log` file. This function should handle file I/O and formatting.",
            "dependencies": [],
            "details": "The `logAuditEvent` function must acquire the current time (assuming NTP sync from Task 20 is complete), format it as a Unix timestamp, and write a string like `[<timestamp>] <event_string>\\n` to the log file. It should open the file in append mode (`FILE_APPEND`) and properly close it after writing. Add error handling for `SPIFFS.begin()` and file operations.",
            "status": "pending",
            "testStrategy": "After flashing, check the serial monitor for messages indicating SPIFFS has mounted successfully. Manually call `logAuditEvent(\"TEST_EVENT\")` from `setup()` and implement a temporary serial command to read and print `/audit.log` to verify the entry was written correctly."
          },
          {
            "id": 2,
            "title": "Firmware: Implement `emergencyStop` Function and WebSocket Handler",
            "description": "Create a new function `void emergencyStop()` in the main `.ino` file. This function will iterate through all defined relay GPIO pins and set their state to OFF using `digitalWrite`. Update the WebSocket event handler to recognize a new command, `{\"command\": \"estop\"}`, and call `emergencyStop()` when it's received.",
            "dependencies": [],
            "details": "The `emergencyStop()` function should directly set GPIOs to their safe state (e.g., `LOW` or `HIGH` depending on relay type) for immediate effect, bypassing the standard `setPumpState` logic. In the WebSocket handler, add a new `if` condition to check for `doc[\"command\"] == \"estop\"`.",
            "status": "pending",
            "testStrategy": "Use a WebSocket client to send `{\"command\": \"estop\"}`. Verify that all relays (or connected LEDs) turn off instantly."
          },
          {
            "id": 3,
            "title": "Firmware: Integrate Audit Logging for Critical Events",
            "description": "Call the `logAuditEvent()` function from all required locations in the firmware to ensure a complete audit trail. This includes pump state changes, E-Stop activation, and safety timeouts.",
            "dependencies": [
              "21.1",
              "21.2"
            ],
            "details": "1. In `setPumpState()`, call `logAuditEvent()` with messages like `PUMP_1_ON` or `PUMP_1_OFF`. 2. In `emergencyStop()`, call `logAuditEvent(\"ESTOP_ACTIVATED\")`. 3. In the pump timeout logic (from Task 18), call `logAuditEvent()` with a message like `PUMP_2_TIMEOUT` when a pump is automatically shut down.",
            "status": "pending",
            "testStrategy": "Perform a sequence of actions: toggle pumps, trigger an E-Stop, and (if possible) trigger a safety timeout. Use a temporary endpoint or serial command to dump the contents of `/audit.log` and verify all actions were recorded with correct timestamps."
          },
          {
            "id": 4,
            "title": "Frontend: Add Emergency Stop Button to Dashboard UI",
            "description": "In the `src/app/page.tsx` file, add a Shadcn `Button` component for the emergency stop. The button should be visually distinct, using the `destructive` variant, and clearly labeled 'Emergency Stop'.",
            "dependencies": [],
            "details": "Place the button in a prominent position on the dashboard, perhaps in the main header or a dedicated 'System Controls' card, to ensure it is easily accessible but distinct from individual pump controls. Example: `<Button variant='destructive' size='lg'>Emergency Stop</Button>`.",
            "status": "pending",
            "testStrategy": "Load the web UI and confirm the 'Emergency Stop' button is visible, red, and positioned correctly on the page."
          },
          {
            "id": 5,
            "title": "Frontend: Connect E-Stop Button to WebSocket Command",
            "description": "Implement the `onClick` handler for the 'Emergency Stop' button. When clicked, the handler should use the existing WebSocket instance to send the `{\"command\": \"estop\"}` JSON message to the ESP32.",
            "dependencies": [
              "21.2",
              "21.4"
            ],
            "details": "In `src/app/page.tsx`, add an `onClick` prop to the button. The handler function should call the WebSocket `send` method. To prevent accidental activation, implement a browser confirmation dialog using `window.confirm('Are you sure you want to perform an emergency stop?')` before sending the command.",
            "status": "pending",
            "testStrategy": "Click the 'Emergency Stop' button in the UI. Verify the confirmation dialog appears. After confirming, check the browser's developer tools to see the WebSocket message being sent and observe that the physical relays all turn off."
          }
        ]
      },
      {
        "id": 22,
        "title": "Implement First Automation Rule: Temperature-Based Heating Control",
        "description": "Introduce the first automation rule from Phase 2 into the firmware. The heating pump will be automatically controlled based on the water temperature from the DS18B20 sensor, with a manual override capability.",
        "details": "1. **Configuration:** In the firmware, define `targetTemperature` (e.g., 28.0°C) and `temperatureHysteresis` (e.g., 0.5°C). 2. **Control Logic:** In the main loop, add logic for the heating pump: turn ON if `currentTemp < targetTemp - hysteresis`, and turn OFF if `currentTemp > targetTemp + hysteresis`. 3. **Manual Override:** If a manual command for the heating pump is received from the UI, disable the automation logic for that pump for a fixed period (e.g., 1 hour) before reverting to 'AUTO' mode. 4. **UI Feedback:** Enhance the WebSocket status JSON to include the mode for each pump (e.g., `\"mode\": \"AUTO\"` or `\"mode\": \"MANUAL\"`). The frontend dashboard should display this mode on the pump's `Card`.",
        "testStrategy": "Set `targetTemperature` to a value slightly above the current ambient temperature and verify the heating pump turns on. Warm the sensor until it exceeds `targetTemperature + hysteresis` and verify the pump turns off. While in AUTO mode, use the UI to manually toggle the pump and verify its mode changes to MANUAL on the dashboard.",
        "priority": "medium",
        "dependencies": [
          19,
          20
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Firmware: Add Automation Configuration and State Variables",
            "description": "In the main firmware file (e.g., ESP32-Tuya.ino), define the new configuration variables `targetTemperature` and `temperatureHysteresis`. Additionally, create a data structure or extend the existing pump state management to include a `mode` (enum/string for 'AUTO'/'MANUAL') and a `manualOverrideEndTime` (unsigned long) for each pump.",
            "dependencies": [],
            "details": "Define `const float targetTemperature = 28.0;` and `const float temperatureHysteresis = 0.5;`. Create an enum `PumpMode { AUTO, MANUAL };`. Create a struct `PumpState` containing `bool state`, `PumpMode mode`, and `unsigned long manualOverrideEndTime`. Declare an array `PumpState pumpStates[NUM_PUMPS];` and initialize all pumps to `AUTO` mode in `setup()`.",
            "status": "pending",
            "testStrategy": "Compile the firmware to ensure the new variables and structures are correctly defined and initialized without errors. Verify default values are set in the `setup()` function."
          },
          {
            "id": 2,
            "title": "Firmware: Implement Temperature-Based Control Logic",
            "description": "In the main `loop()`, create a new function `handleHeatingAutomation()` that reads the current temperature from the DS18B20 sensor. This function will control the heating pump (assuming pump 0) based on the target temperature and hysteresis, but only if its mode is 'AUTO'.",
            "dependencies": [
              "22.1"
            ],
            "details": "The `handleHeatingAutomation()` function should be called on each loop. Inside, check `if (pumpStates[HEATING_PUMP_ID].mode == AUTO)`. If true, implement the logic: `if (currentTemp < targetTemperature - temperatureHysteresis)` call `setPumpState(HEATING_PUMP_ID, true)`, and `if (currentTemp > targetTemperature + temperatureHysteresis)` call `setPumpState(HEATING_PUMP_ID, false)`. Ensure `HEATING_PUMP_ID` is defined.",
            "status": "pending",
            "testStrategy": "Set a `targetTemperature` close to the ambient temperature. Verify the pump turns on. Use a heat source to warm the DS18B20 sensor above `targetTemperature + temperatureHysteresis` and verify the pump turns off."
          },
          {
            "id": 3,
            "title": "Firmware: Implement Manual Override and Auto-Revert Logic",
            "description": "Modify the WebSocket command handler for `set_pump`. When a manual command is received for the heating pump, set its mode to 'MANUAL' and record an override end time. In the main `loop()`, add logic to check if the override time has expired and, if so, revert the pump's mode back to 'AUTO'.",
            "dependencies": [
              "22.1"
            ],
            "details": "In the WebSocket handler, upon receiving a `set_pump` command for the heating pump, set `pumpStates[HEATING_PUMP_ID].mode = MANUAL;` and `pumpStates[HEATING_PUMP_ID].manualOverrideEndTime = millis() + 3600000;` (1 hour). In the main `loop()`, add a check: `if (pumpStates[HEATING_PUMP_ID].mode == MANUAL && millis() > pumpStates[HEATING_PUMP_ID].manualOverrideEndTime)`, then set `pumpStates[HEATING_PUMP_ID].mode = AUTO;`.",
            "status": "pending",
            "testStrategy": "Set a short override duration (e.g., 15 seconds). Manually toggle the heating pump via the UI. Verify its mode becomes 'MANUAL'. Wait for the duration to pass and verify the automation logic takes over again, indicating a switch back to 'AUTO' mode."
          },
          {
            "id": 4,
            "title": "Firmware: Enhance WebSocket Status JSON with Pump Mode",
            "description": "Update the function that generates and broadcasts the system status JSON via WebSockets. For each pump object in the `pumps` array, add a new key-value pair `\"mode\": \"AUTO\"` or `\"mode\": \"MANUAL\"` based on its current state.",
            "dependencies": [
              "22.1"
            ],
            "details": "Locate the `sendStatus()` or equivalent function. When serializing the JSON for each pump, convert the `PumpMode` enum to a string. The JSON for a pump should now look like: `{\"id\": 0, \"state\": true, \"mode\": \"MANUAL\"}`. Broadcast this updated status object whenever a pump's state or mode changes.",
            "status": "pending",
            "testStrategy": "Connect to the WebSocket and monitor the broadcasted messages. Manually toggle the heating pump and verify the `mode` field in the JSON payload changes from `AUTO` to `MANUAL`. Wait for the manual override to expire and verify the `mode` reverts to `AUTO` in a subsequent message."
          },
          {
            "id": 5,
            "title": "Frontend: Display Pump Mode on Dashboard Card",
            "description": "Modify the frontend pump `Card` component (e.g., `PumpCard.tsx`) to parse and display the new `mode` field received from the WebSocket status message. Display the mode clearly, for example, using a Shadcn `Badge` component.",
            "dependencies": [
              "22.4"
            ],
            "details": "Update the TypeScript interface for the pump state to include `mode: 'AUTO' | 'MANUAL';`. In the `PumpCard` component, render a `<Badge>` next to the card title. The badge should display the text from `props.pump.mode`. Conditionally style the badge if desired (e.g., blue for AUTO, orange for MANUAL).",
            "status": "pending",
            "testStrategy": "Open the web UI. Verify that the heating pump card displays an 'AUTO' badge by default. Manually toggle the pump switch and verify the badge immediately updates to 'MANUAL'. After the override period, verify the badge reverts to 'AUTO' when the backend automation resumes control."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-18T01:51:38.652Z",
      "updated": "2025-09-18T03:41:54.112Z",
      "description": "Tasks for master context"
    }
  }
}